Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AUTO
    BREAK
    CASE
    COMMA
    CONST
    CONTINUE
    DEFAULT
    DO
    ENUM
    EXTERN
    GOTO
    LBRACKET
    LONG
    RBRACKET
    REGISTER
    RETURN
    SHORT
    SIGNED
    SIZEOF
    STATIC
    STRING
    STRUCT
    SWITCH
    TYPEDEF
    UNION
    UNSIGNED
    VOLATILE
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement_list statement
Rule 3     statement_list -> statement
Rule 4     statement -> assignment
Rule 5     statement -> if_statement
Rule 6     statement -> for_statement
Rule 7     statement -> block
Rule 8     statement -> declaration
Rule 9     statement -> increment_statement
Rule 10    statement -> decrement_statement
Rule 11    increment_statement -> ID INCREMENT SEMICOLON
Rule 12    decrement_statement -> ID DECREMENT SEMICOLON
Rule 13    declaration -> INT ID SEMICOLON
Rule 14    declaration -> FLOAT ID SEMICOLON
Rule 15    declaration -> CHAR ID SEMICOLON
Rule 16    declaration -> DOUBLE ID SEMICOLON
Rule 17    declaration -> VOID ID SEMICOLON
Rule 18    declaration -> INT ID ASSIGN expression SEMICOLON
Rule 19    declaration -> FLOAT ID ASSIGN expression SEMICOLON
Rule 20    declaration -> CHAR ID ASSIGN expression SEMICOLON
Rule 21    declaration -> DOUBLE ID ASSIGN expression SEMICOLON
Rule 22    assignment -> ID ASSIGN expression SEMICOLON
Rule 23    if_statement -> IF LPAREN condition RPAREN statement
Rule 24    if_statement -> IF LPAREN condition RPAREN statement ELSE statement
Rule 25    for_statement -> FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement
Rule 26    for_init -> assignment_no_semicolon
Rule 27    for_init -> empty
Rule 28    assignment_no_semicolon -> ID ASSIGN expression
Rule 29    empty -> <empty>
Rule 30    for_increment -> ID ASSIGN expression
Rule 31    for_increment -> ID INCREMENT
Rule 32    for_increment -> ID DECREMENT
Rule 33    block -> LBRACE statement_list RBRACE
Rule 34    expression -> expression PLUS expression
Rule 35    expression -> expression MINUS expression
Rule 36    expression -> expression TIMES expression
Rule 37    expression -> expression DIVIDE expression
Rule 38    expression -> expression MODULO expression
Rule 39    expression -> MINUS expression
Rule 40    expression -> ID
Rule 41    expression -> CONSTANT
Rule 42    expression -> FLOAT_CONSTANT
Rule 43    expression -> LPAREN expression RPAREN
Rule 44    condition -> expression LT expression
Rule 45    condition -> expression LE expression
Rule 46    condition -> expression GT expression
Rule 47    condition -> expression GE expression
Rule 48    condition -> expression EQ expression
Rule 49    condition -> expression NE expression

Terminals, with rules where they appear

ASSIGN               : 18 19 20 21 22 28 30
AUTO                 : 
BREAK                : 
CASE                 : 
CHAR                 : 15 20
COMMA                : 
CONST                : 
CONSTANT             : 41
CONTINUE             : 
DECREMENT            : 12 32
DEFAULT              : 
DIVIDE               : 37
DO                   : 
DOUBLE               : 16 21
ELSE                 : 24
ENUM                 : 
EQ                   : 48
EXTERN               : 
FLOAT                : 14 19
FLOAT_CONSTANT       : 42
FOR                  : 25
GE                   : 47
GOTO                 : 
GT                   : 46
ID                   : 11 12 13 14 15 16 17 18 19 20 21 22 28 30 31 32 40
IF                   : 23 24
INCREMENT            : 11 31
INT                  : 13 18
LBRACE               : 33
LBRACKET             : 
LE                   : 45
LONG                 : 
LPAREN               : 23 24 25 43
LT                   : 44
MINUS                : 35 39
MODULO               : 38
NE                   : 49
PLUS                 : 34
RBRACE               : 33
RBRACKET             : 
REGISTER             : 
RETURN               : 
RPAREN               : 23 24 25 43
SEMICOLON            : 11 12 13 14 15 16 17 18 19 20 21 22 25 25
SHORT                : 
SIGNED               : 
SIZEOF               : 
STATIC               : 
STRING               : 
STRUCT               : 
SWITCH               : 
TIMES                : 36
TYPEDEF              : 
UNION                : 
UNSIGNED             : 
VOID                 : 17
VOLATILE             : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

assignment           : 4
assignment_no_semicolon : 26
block                : 7
condition            : 23 24 25
declaration          : 8
decrement_statement  : 10
empty                : 27
expression           : 18 19 20 21 22 28 30 34 34 35 35 36 36 37 37 38 38 39 43 44 44 45 45 46 46 47 47 48 48 49 49
for_increment        : 25
for_init             : 25
for_statement        : 6
if_statement         : 5
increment_statement  : 9
program              : 0
statement            : 2 3 23 24 24 25
statement_list       : 1 2 33

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . assignment
    (5) statement -> . if_statement
    (6) statement -> . for_statement
    (7) statement -> . block
    (8) statement -> . declaration
    (9) statement -> . increment_statement
    (10) statement -> . decrement_statement
    (22) assignment -> . ID ASSIGN expression SEMICOLON
    (23) if_statement -> . IF LPAREN condition RPAREN statement
    (24) if_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (25) for_statement -> . FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement
    (33) block -> . LBRACE statement_list RBRACE
    (13) declaration -> . INT ID SEMICOLON
    (14) declaration -> . FLOAT ID SEMICOLON
    (15) declaration -> . CHAR ID SEMICOLON
    (16) declaration -> . DOUBLE ID SEMICOLON
    (17) declaration -> . VOID ID SEMICOLON
    (18) declaration -> . INT ID ASSIGN expression SEMICOLON
    (19) declaration -> . FLOAT ID ASSIGN expression SEMICOLON
    (20) declaration -> . CHAR ID ASSIGN expression SEMICOLON
    (21) declaration -> . DOUBLE ID ASSIGN expression SEMICOLON
    (11) increment_statement -> . ID INCREMENT SEMICOLON
    (12) decrement_statement -> . ID DECREMENT SEMICOLON

    ID              shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    LBRACE          shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    DOUBLE          shift and go to state 18
    VOID            shift and go to state 19

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    if_statement                   shift and go to state 5
    for_statement                  shift and go to state 6
    block                          shift and go to state 7
    declaration                    shift and go to state 8
    increment_statement            shift and go to state 9
    decrement_statement            shift and go to state 10

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .
    (2) statement_list -> statement_list . statement
    (4) statement -> . assignment
    (5) statement -> . if_statement
    (6) statement -> . for_statement
    (7) statement -> . block
    (8) statement -> . declaration
    (9) statement -> . increment_statement
    (10) statement -> . decrement_statement
    (22) assignment -> . ID ASSIGN expression SEMICOLON
    (23) if_statement -> . IF LPAREN condition RPAREN statement
    (24) if_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (25) for_statement -> . FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement
    (33) block -> . LBRACE statement_list RBRACE
    (13) declaration -> . INT ID SEMICOLON
    (14) declaration -> . FLOAT ID SEMICOLON
    (15) declaration -> . CHAR ID SEMICOLON
    (16) declaration -> . DOUBLE ID SEMICOLON
    (17) declaration -> . VOID ID SEMICOLON
    (18) declaration -> . INT ID ASSIGN expression SEMICOLON
    (19) declaration -> . FLOAT ID ASSIGN expression SEMICOLON
    (20) declaration -> . CHAR ID ASSIGN expression SEMICOLON
    (21) declaration -> . DOUBLE ID ASSIGN expression SEMICOLON
    (11) increment_statement -> . ID INCREMENT SEMICOLON
    (12) decrement_statement -> . ID DECREMENT SEMICOLON

    $end            reduce using rule 1 (program -> statement_list .)
    ID              shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    LBRACE          shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    DOUBLE          shift and go to state 18
    VOID            shift and go to state 19

    statement                      shift and go to state 20
    assignment                     shift and go to state 4
    if_statement                   shift and go to state 5
    for_statement                  shift and go to state 6
    block                          shift and go to state 7
    declaration                    shift and go to state 8
    increment_statement            shift and go to state 9
    decrement_statement            shift and go to state 10

state 3

    (3) statement_list -> statement .

    ID              reduce using rule 3 (statement_list -> statement .)
    IF              reduce using rule 3 (statement_list -> statement .)
    FOR             reduce using rule 3 (statement_list -> statement .)
    LBRACE          reduce using rule 3 (statement_list -> statement .)
    INT             reduce using rule 3 (statement_list -> statement .)
    FLOAT           reduce using rule 3 (statement_list -> statement .)
    CHAR            reduce using rule 3 (statement_list -> statement .)
    DOUBLE          reduce using rule 3 (statement_list -> statement .)
    VOID            reduce using rule 3 (statement_list -> statement .)
    $end            reduce using rule 3 (statement_list -> statement .)
    RBRACE          reduce using rule 3 (statement_list -> statement .)


state 4

    (4) statement -> assignment .

    ID              reduce using rule 4 (statement -> assignment .)
    IF              reduce using rule 4 (statement -> assignment .)
    FOR             reduce using rule 4 (statement -> assignment .)
    LBRACE          reduce using rule 4 (statement -> assignment .)
    INT             reduce using rule 4 (statement -> assignment .)
    FLOAT           reduce using rule 4 (statement -> assignment .)
    CHAR            reduce using rule 4 (statement -> assignment .)
    DOUBLE          reduce using rule 4 (statement -> assignment .)
    VOID            reduce using rule 4 (statement -> assignment .)
    $end            reduce using rule 4 (statement -> assignment .)
    RBRACE          reduce using rule 4 (statement -> assignment .)
    ELSE            reduce using rule 4 (statement -> assignment .)


state 5

    (5) statement -> if_statement .

    ID              reduce using rule 5 (statement -> if_statement .)
    IF              reduce using rule 5 (statement -> if_statement .)
    FOR             reduce using rule 5 (statement -> if_statement .)
    LBRACE          reduce using rule 5 (statement -> if_statement .)
    INT             reduce using rule 5 (statement -> if_statement .)
    FLOAT           reduce using rule 5 (statement -> if_statement .)
    CHAR            reduce using rule 5 (statement -> if_statement .)
    DOUBLE          reduce using rule 5 (statement -> if_statement .)
    VOID            reduce using rule 5 (statement -> if_statement .)
    $end            reduce using rule 5 (statement -> if_statement .)
    RBRACE          reduce using rule 5 (statement -> if_statement .)
    ELSE            reduce using rule 5 (statement -> if_statement .)


state 6

    (6) statement -> for_statement .

    ID              reduce using rule 6 (statement -> for_statement .)
    IF              reduce using rule 6 (statement -> for_statement .)
    FOR             reduce using rule 6 (statement -> for_statement .)
    LBRACE          reduce using rule 6 (statement -> for_statement .)
    INT             reduce using rule 6 (statement -> for_statement .)
    FLOAT           reduce using rule 6 (statement -> for_statement .)
    CHAR            reduce using rule 6 (statement -> for_statement .)
    DOUBLE          reduce using rule 6 (statement -> for_statement .)
    VOID            reduce using rule 6 (statement -> for_statement .)
    $end            reduce using rule 6 (statement -> for_statement .)
    RBRACE          reduce using rule 6 (statement -> for_statement .)
    ELSE            reduce using rule 6 (statement -> for_statement .)


state 7

    (7) statement -> block .

    ID              reduce using rule 7 (statement -> block .)
    IF              reduce using rule 7 (statement -> block .)
    FOR             reduce using rule 7 (statement -> block .)
    LBRACE          reduce using rule 7 (statement -> block .)
    INT             reduce using rule 7 (statement -> block .)
    FLOAT           reduce using rule 7 (statement -> block .)
    CHAR            reduce using rule 7 (statement -> block .)
    DOUBLE          reduce using rule 7 (statement -> block .)
    VOID            reduce using rule 7 (statement -> block .)
    $end            reduce using rule 7 (statement -> block .)
    RBRACE          reduce using rule 7 (statement -> block .)
    ELSE            reduce using rule 7 (statement -> block .)


state 8

    (8) statement -> declaration .

    ID              reduce using rule 8 (statement -> declaration .)
    IF              reduce using rule 8 (statement -> declaration .)
    FOR             reduce using rule 8 (statement -> declaration .)
    LBRACE          reduce using rule 8 (statement -> declaration .)
    INT             reduce using rule 8 (statement -> declaration .)
    FLOAT           reduce using rule 8 (statement -> declaration .)
    CHAR            reduce using rule 8 (statement -> declaration .)
    DOUBLE          reduce using rule 8 (statement -> declaration .)
    VOID            reduce using rule 8 (statement -> declaration .)
    $end            reduce using rule 8 (statement -> declaration .)
    RBRACE          reduce using rule 8 (statement -> declaration .)
    ELSE            reduce using rule 8 (statement -> declaration .)


state 9

    (9) statement -> increment_statement .

    ID              reduce using rule 9 (statement -> increment_statement .)
    IF              reduce using rule 9 (statement -> increment_statement .)
    FOR             reduce using rule 9 (statement -> increment_statement .)
    LBRACE          reduce using rule 9 (statement -> increment_statement .)
    INT             reduce using rule 9 (statement -> increment_statement .)
    FLOAT           reduce using rule 9 (statement -> increment_statement .)
    CHAR            reduce using rule 9 (statement -> increment_statement .)
    DOUBLE          reduce using rule 9 (statement -> increment_statement .)
    VOID            reduce using rule 9 (statement -> increment_statement .)
    $end            reduce using rule 9 (statement -> increment_statement .)
    RBRACE          reduce using rule 9 (statement -> increment_statement .)
    ELSE            reduce using rule 9 (statement -> increment_statement .)


state 10

    (10) statement -> decrement_statement .

    ID              reduce using rule 10 (statement -> decrement_statement .)
    IF              reduce using rule 10 (statement -> decrement_statement .)
    FOR             reduce using rule 10 (statement -> decrement_statement .)
    LBRACE          reduce using rule 10 (statement -> decrement_statement .)
    INT             reduce using rule 10 (statement -> decrement_statement .)
    FLOAT           reduce using rule 10 (statement -> decrement_statement .)
    CHAR            reduce using rule 10 (statement -> decrement_statement .)
    DOUBLE          reduce using rule 10 (statement -> decrement_statement .)
    VOID            reduce using rule 10 (statement -> decrement_statement .)
    $end            reduce using rule 10 (statement -> decrement_statement .)
    RBRACE          reduce using rule 10 (statement -> decrement_statement .)
    ELSE            reduce using rule 10 (statement -> decrement_statement .)


state 11

    (22) assignment -> ID . ASSIGN expression SEMICOLON
    (11) increment_statement -> ID . INCREMENT SEMICOLON
    (12) decrement_statement -> ID . DECREMENT SEMICOLON

    ASSIGN          shift and go to state 21
    INCREMENT       shift and go to state 22
    DECREMENT       shift and go to state 23


state 12

    (23) if_statement -> IF . LPAREN condition RPAREN statement
    (24) if_statement -> IF . LPAREN condition RPAREN statement ELSE statement

    LPAREN          shift and go to state 24


state 13

    (25) for_statement -> FOR . LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement

    LPAREN          shift and go to state 25


state 14

    (33) block -> LBRACE . statement_list RBRACE
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . assignment
    (5) statement -> . if_statement
    (6) statement -> . for_statement
    (7) statement -> . block
    (8) statement -> . declaration
    (9) statement -> . increment_statement
    (10) statement -> . decrement_statement
    (22) assignment -> . ID ASSIGN expression SEMICOLON
    (23) if_statement -> . IF LPAREN condition RPAREN statement
    (24) if_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (25) for_statement -> . FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement
    (33) block -> . LBRACE statement_list RBRACE
    (13) declaration -> . INT ID SEMICOLON
    (14) declaration -> . FLOAT ID SEMICOLON
    (15) declaration -> . CHAR ID SEMICOLON
    (16) declaration -> . DOUBLE ID SEMICOLON
    (17) declaration -> . VOID ID SEMICOLON
    (18) declaration -> . INT ID ASSIGN expression SEMICOLON
    (19) declaration -> . FLOAT ID ASSIGN expression SEMICOLON
    (20) declaration -> . CHAR ID ASSIGN expression SEMICOLON
    (21) declaration -> . DOUBLE ID ASSIGN expression SEMICOLON
    (11) increment_statement -> . ID INCREMENT SEMICOLON
    (12) decrement_statement -> . ID DECREMENT SEMICOLON

    ID              shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    LBRACE          shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    DOUBLE          shift and go to state 18
    VOID            shift and go to state 19

    statement_list                 shift and go to state 26
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    if_statement                   shift and go to state 5
    for_statement                  shift and go to state 6
    block                          shift and go to state 7
    declaration                    shift and go to state 8
    increment_statement            shift and go to state 9
    decrement_statement            shift and go to state 10

state 15

    (13) declaration -> INT . ID SEMICOLON
    (18) declaration -> INT . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 27


state 16

    (14) declaration -> FLOAT . ID SEMICOLON
    (19) declaration -> FLOAT . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 28


state 17

    (15) declaration -> CHAR . ID SEMICOLON
    (20) declaration -> CHAR . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 29


state 18

    (16) declaration -> DOUBLE . ID SEMICOLON
    (21) declaration -> DOUBLE . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 30


state 19

    (17) declaration -> VOID . ID SEMICOLON

    ID              shift and go to state 31


state 20

    (2) statement_list -> statement_list statement .

    ID              reduce using rule 2 (statement_list -> statement_list statement .)
    IF              reduce using rule 2 (statement_list -> statement_list statement .)
    FOR             reduce using rule 2 (statement_list -> statement_list statement .)
    LBRACE          reduce using rule 2 (statement_list -> statement_list statement .)
    INT             reduce using rule 2 (statement_list -> statement_list statement .)
    FLOAT           reduce using rule 2 (statement_list -> statement_list statement .)
    CHAR            reduce using rule 2 (statement_list -> statement_list statement .)
    DOUBLE          reduce using rule 2 (statement_list -> statement_list statement .)
    VOID            reduce using rule 2 (statement_list -> statement_list statement .)
    $end            reduce using rule 2 (statement_list -> statement_list statement .)
    RBRACE          reduce using rule 2 (statement_list -> statement_list statement .)


state 21

    (22) assignment -> ID ASSIGN . expression SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    expression                     shift and go to state 33

state 22

    (11) increment_statement -> ID INCREMENT . SEMICOLON

    SEMICOLON       shift and go to state 38


state 23

    (12) decrement_statement -> ID DECREMENT . SEMICOLON

    SEMICOLON       shift and go to state 39


state 24

    (23) if_statement -> IF LPAREN . condition RPAREN statement
    (24) if_statement -> IF LPAREN . condition RPAREN statement ELSE statement
    (44) condition -> . expression LT expression
    (45) condition -> . expression LE expression
    (46) condition -> . expression GT expression
    (47) condition -> . expression GE expression
    (48) condition -> . expression EQ expression
    (49) condition -> . expression NE expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    condition                      shift and go to state 40
    expression                     shift and go to state 41

state 25

    (25) for_statement -> FOR LPAREN . for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement
    (26) for_init -> . assignment_no_semicolon
    (27) for_init -> . empty
    (28) assignment_no_semicolon -> . ID ASSIGN expression
    (29) empty -> .

    ID              shift and go to state 45
    SEMICOLON       reduce using rule 29 (empty -> .)

    for_init                       shift and go to state 42
    assignment_no_semicolon        shift and go to state 43
    empty                          shift and go to state 44

state 26

    (33) block -> LBRACE statement_list . RBRACE
    (2) statement_list -> statement_list . statement
    (4) statement -> . assignment
    (5) statement -> . if_statement
    (6) statement -> . for_statement
    (7) statement -> . block
    (8) statement -> . declaration
    (9) statement -> . increment_statement
    (10) statement -> . decrement_statement
    (22) assignment -> . ID ASSIGN expression SEMICOLON
    (23) if_statement -> . IF LPAREN condition RPAREN statement
    (24) if_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (25) for_statement -> . FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement
    (33) block -> . LBRACE statement_list RBRACE
    (13) declaration -> . INT ID SEMICOLON
    (14) declaration -> . FLOAT ID SEMICOLON
    (15) declaration -> . CHAR ID SEMICOLON
    (16) declaration -> . DOUBLE ID SEMICOLON
    (17) declaration -> . VOID ID SEMICOLON
    (18) declaration -> . INT ID ASSIGN expression SEMICOLON
    (19) declaration -> . FLOAT ID ASSIGN expression SEMICOLON
    (20) declaration -> . CHAR ID ASSIGN expression SEMICOLON
    (21) declaration -> . DOUBLE ID ASSIGN expression SEMICOLON
    (11) increment_statement -> . ID INCREMENT SEMICOLON
    (12) decrement_statement -> . ID DECREMENT SEMICOLON

    RBRACE          shift and go to state 46
    ID              shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    LBRACE          shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    DOUBLE          shift and go to state 18
    VOID            shift and go to state 19

    statement                      shift and go to state 20
    assignment                     shift and go to state 4
    if_statement                   shift and go to state 5
    for_statement                  shift and go to state 6
    block                          shift and go to state 7
    declaration                    shift and go to state 8
    increment_statement            shift and go to state 9
    decrement_statement            shift and go to state 10

state 27

    (13) declaration -> INT ID . SEMICOLON
    (18) declaration -> INT ID . ASSIGN expression SEMICOLON

    SEMICOLON       shift and go to state 47
    ASSIGN          shift and go to state 48


state 28

    (14) declaration -> FLOAT ID . SEMICOLON
    (19) declaration -> FLOAT ID . ASSIGN expression SEMICOLON

    SEMICOLON       shift and go to state 49
    ASSIGN          shift and go to state 50


state 29

    (15) declaration -> CHAR ID . SEMICOLON
    (20) declaration -> CHAR ID . ASSIGN expression SEMICOLON

    SEMICOLON       shift and go to state 51
    ASSIGN          shift and go to state 52


state 30

    (16) declaration -> DOUBLE ID . SEMICOLON
    (21) declaration -> DOUBLE ID . ASSIGN expression SEMICOLON

    SEMICOLON       shift and go to state 53
    ASSIGN          shift and go to state 54


state 31

    (17) declaration -> VOID ID . SEMICOLON

    SEMICOLON       shift and go to state 55


state 32

    (40) expression -> ID .

    SEMICOLON       reduce using rule 40 (expression -> ID .)
    PLUS            reduce using rule 40 (expression -> ID .)
    MINUS           reduce using rule 40 (expression -> ID .)
    TIMES           reduce using rule 40 (expression -> ID .)
    DIVIDE          reduce using rule 40 (expression -> ID .)
    MODULO          reduce using rule 40 (expression -> ID .)
    LT              reduce using rule 40 (expression -> ID .)
    LE              reduce using rule 40 (expression -> ID .)
    GT              reduce using rule 40 (expression -> ID .)
    GE              reduce using rule 40 (expression -> ID .)
    EQ              reduce using rule 40 (expression -> ID .)
    NE              reduce using rule 40 (expression -> ID .)
    RPAREN          reduce using rule 40 (expression -> ID .)


state 33

    (22) assignment -> ID ASSIGN expression . SEMICOLON
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . MODULO expression

    SEMICOLON       shift and go to state 56
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    MODULO          shift and go to state 61


state 34

    (39) expression -> MINUS . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    expression                     shift and go to state 62

state 35

    (41) expression -> CONSTANT .

    SEMICOLON       reduce using rule 41 (expression -> CONSTANT .)
    PLUS            reduce using rule 41 (expression -> CONSTANT .)
    MINUS           reduce using rule 41 (expression -> CONSTANT .)
    TIMES           reduce using rule 41 (expression -> CONSTANT .)
    DIVIDE          reduce using rule 41 (expression -> CONSTANT .)
    MODULO          reduce using rule 41 (expression -> CONSTANT .)
    LT              reduce using rule 41 (expression -> CONSTANT .)
    LE              reduce using rule 41 (expression -> CONSTANT .)
    GT              reduce using rule 41 (expression -> CONSTANT .)
    GE              reduce using rule 41 (expression -> CONSTANT .)
    EQ              reduce using rule 41 (expression -> CONSTANT .)
    NE              reduce using rule 41 (expression -> CONSTANT .)
    RPAREN          reduce using rule 41 (expression -> CONSTANT .)


state 36

    (42) expression -> FLOAT_CONSTANT .

    SEMICOLON       reduce using rule 42 (expression -> FLOAT_CONSTANT .)
    PLUS            reduce using rule 42 (expression -> FLOAT_CONSTANT .)
    MINUS           reduce using rule 42 (expression -> FLOAT_CONSTANT .)
    TIMES           reduce using rule 42 (expression -> FLOAT_CONSTANT .)
    DIVIDE          reduce using rule 42 (expression -> FLOAT_CONSTANT .)
    MODULO          reduce using rule 42 (expression -> FLOAT_CONSTANT .)
    LT              reduce using rule 42 (expression -> FLOAT_CONSTANT .)
    LE              reduce using rule 42 (expression -> FLOAT_CONSTANT .)
    GT              reduce using rule 42 (expression -> FLOAT_CONSTANT .)
    GE              reduce using rule 42 (expression -> FLOAT_CONSTANT .)
    EQ              reduce using rule 42 (expression -> FLOAT_CONSTANT .)
    NE              reduce using rule 42 (expression -> FLOAT_CONSTANT .)
    RPAREN          reduce using rule 42 (expression -> FLOAT_CONSTANT .)


state 37

    (43) expression -> LPAREN . expression RPAREN
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    expression                     shift and go to state 63

state 38

    (11) increment_statement -> ID INCREMENT SEMICOLON .

    ID              reduce using rule 11 (increment_statement -> ID INCREMENT SEMICOLON .)
    IF              reduce using rule 11 (increment_statement -> ID INCREMENT SEMICOLON .)
    FOR             reduce using rule 11 (increment_statement -> ID INCREMENT SEMICOLON .)
    LBRACE          reduce using rule 11 (increment_statement -> ID INCREMENT SEMICOLON .)
    INT             reduce using rule 11 (increment_statement -> ID INCREMENT SEMICOLON .)
    FLOAT           reduce using rule 11 (increment_statement -> ID INCREMENT SEMICOLON .)
    CHAR            reduce using rule 11 (increment_statement -> ID INCREMENT SEMICOLON .)
    DOUBLE          reduce using rule 11 (increment_statement -> ID INCREMENT SEMICOLON .)
    VOID            reduce using rule 11 (increment_statement -> ID INCREMENT SEMICOLON .)
    $end            reduce using rule 11 (increment_statement -> ID INCREMENT SEMICOLON .)
    RBRACE          reduce using rule 11 (increment_statement -> ID INCREMENT SEMICOLON .)
    ELSE            reduce using rule 11 (increment_statement -> ID INCREMENT SEMICOLON .)


state 39

    (12) decrement_statement -> ID DECREMENT SEMICOLON .

    ID              reduce using rule 12 (decrement_statement -> ID DECREMENT SEMICOLON .)
    IF              reduce using rule 12 (decrement_statement -> ID DECREMENT SEMICOLON .)
    FOR             reduce using rule 12 (decrement_statement -> ID DECREMENT SEMICOLON .)
    LBRACE          reduce using rule 12 (decrement_statement -> ID DECREMENT SEMICOLON .)
    INT             reduce using rule 12 (decrement_statement -> ID DECREMENT SEMICOLON .)
    FLOAT           reduce using rule 12 (decrement_statement -> ID DECREMENT SEMICOLON .)
    CHAR            reduce using rule 12 (decrement_statement -> ID DECREMENT SEMICOLON .)
    DOUBLE          reduce using rule 12 (decrement_statement -> ID DECREMENT SEMICOLON .)
    VOID            reduce using rule 12 (decrement_statement -> ID DECREMENT SEMICOLON .)
    $end            reduce using rule 12 (decrement_statement -> ID DECREMENT SEMICOLON .)
    RBRACE          reduce using rule 12 (decrement_statement -> ID DECREMENT SEMICOLON .)
    ELSE            reduce using rule 12 (decrement_statement -> ID DECREMENT SEMICOLON .)


state 40

    (23) if_statement -> IF LPAREN condition . RPAREN statement
    (24) if_statement -> IF LPAREN condition . RPAREN statement ELSE statement

    RPAREN          shift and go to state 64


state 41

    (44) condition -> expression . LT expression
    (45) condition -> expression . LE expression
    (46) condition -> expression . GT expression
    (47) condition -> expression . GE expression
    (48) condition -> expression . EQ expression
    (49) condition -> expression . NE expression
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . MODULO expression

    LT              shift and go to state 65
    LE              shift and go to state 66
    GT              shift and go to state 67
    GE              shift and go to state 68
    EQ              shift and go to state 69
    NE              shift and go to state 70
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    MODULO          shift and go to state 61


state 42

    (25) for_statement -> FOR LPAREN for_init . SEMICOLON condition SEMICOLON for_increment RPAREN statement

    SEMICOLON       shift and go to state 71


state 43

    (26) for_init -> assignment_no_semicolon .

    SEMICOLON       reduce using rule 26 (for_init -> assignment_no_semicolon .)


state 44

    (27) for_init -> empty .

    SEMICOLON       reduce using rule 27 (for_init -> empty .)


state 45

    (28) assignment_no_semicolon -> ID . ASSIGN expression

    ASSIGN          shift and go to state 72


state 46

    (33) block -> LBRACE statement_list RBRACE .

    ID              reduce using rule 33 (block -> LBRACE statement_list RBRACE .)
    IF              reduce using rule 33 (block -> LBRACE statement_list RBRACE .)
    FOR             reduce using rule 33 (block -> LBRACE statement_list RBRACE .)
    LBRACE          reduce using rule 33 (block -> LBRACE statement_list RBRACE .)
    INT             reduce using rule 33 (block -> LBRACE statement_list RBRACE .)
    FLOAT           reduce using rule 33 (block -> LBRACE statement_list RBRACE .)
    CHAR            reduce using rule 33 (block -> LBRACE statement_list RBRACE .)
    DOUBLE          reduce using rule 33 (block -> LBRACE statement_list RBRACE .)
    VOID            reduce using rule 33 (block -> LBRACE statement_list RBRACE .)
    $end            reduce using rule 33 (block -> LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 33 (block -> LBRACE statement_list RBRACE .)
    ELSE            reduce using rule 33 (block -> LBRACE statement_list RBRACE .)


state 47

    (13) declaration -> INT ID SEMICOLON .

    ID              reduce using rule 13 (declaration -> INT ID SEMICOLON .)
    IF              reduce using rule 13 (declaration -> INT ID SEMICOLON .)
    FOR             reduce using rule 13 (declaration -> INT ID SEMICOLON .)
    LBRACE          reduce using rule 13 (declaration -> INT ID SEMICOLON .)
    INT             reduce using rule 13 (declaration -> INT ID SEMICOLON .)
    FLOAT           reduce using rule 13 (declaration -> INT ID SEMICOLON .)
    CHAR            reduce using rule 13 (declaration -> INT ID SEMICOLON .)
    DOUBLE          reduce using rule 13 (declaration -> INT ID SEMICOLON .)
    VOID            reduce using rule 13 (declaration -> INT ID SEMICOLON .)
    $end            reduce using rule 13 (declaration -> INT ID SEMICOLON .)
    RBRACE          reduce using rule 13 (declaration -> INT ID SEMICOLON .)
    ELSE            reduce using rule 13 (declaration -> INT ID SEMICOLON .)


state 48

    (18) declaration -> INT ID ASSIGN . expression SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    expression                     shift and go to state 73

state 49

    (14) declaration -> FLOAT ID SEMICOLON .

    ID              reduce using rule 14 (declaration -> FLOAT ID SEMICOLON .)
    IF              reduce using rule 14 (declaration -> FLOAT ID SEMICOLON .)
    FOR             reduce using rule 14 (declaration -> FLOAT ID SEMICOLON .)
    LBRACE          reduce using rule 14 (declaration -> FLOAT ID SEMICOLON .)
    INT             reduce using rule 14 (declaration -> FLOAT ID SEMICOLON .)
    FLOAT           reduce using rule 14 (declaration -> FLOAT ID SEMICOLON .)
    CHAR            reduce using rule 14 (declaration -> FLOAT ID SEMICOLON .)
    DOUBLE          reduce using rule 14 (declaration -> FLOAT ID SEMICOLON .)
    VOID            reduce using rule 14 (declaration -> FLOAT ID SEMICOLON .)
    $end            reduce using rule 14 (declaration -> FLOAT ID SEMICOLON .)
    RBRACE          reduce using rule 14 (declaration -> FLOAT ID SEMICOLON .)
    ELSE            reduce using rule 14 (declaration -> FLOAT ID SEMICOLON .)


state 50

    (19) declaration -> FLOAT ID ASSIGN . expression SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    expression                     shift and go to state 74

state 51

    (15) declaration -> CHAR ID SEMICOLON .

    ID              reduce using rule 15 (declaration -> CHAR ID SEMICOLON .)
    IF              reduce using rule 15 (declaration -> CHAR ID SEMICOLON .)
    FOR             reduce using rule 15 (declaration -> CHAR ID SEMICOLON .)
    LBRACE          reduce using rule 15 (declaration -> CHAR ID SEMICOLON .)
    INT             reduce using rule 15 (declaration -> CHAR ID SEMICOLON .)
    FLOAT           reduce using rule 15 (declaration -> CHAR ID SEMICOLON .)
    CHAR            reduce using rule 15 (declaration -> CHAR ID SEMICOLON .)
    DOUBLE          reduce using rule 15 (declaration -> CHAR ID SEMICOLON .)
    VOID            reduce using rule 15 (declaration -> CHAR ID SEMICOLON .)
    $end            reduce using rule 15 (declaration -> CHAR ID SEMICOLON .)
    RBRACE          reduce using rule 15 (declaration -> CHAR ID SEMICOLON .)
    ELSE            reduce using rule 15 (declaration -> CHAR ID SEMICOLON .)


state 52

    (20) declaration -> CHAR ID ASSIGN . expression SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    expression                     shift and go to state 75

state 53

    (16) declaration -> DOUBLE ID SEMICOLON .

    ID              reduce using rule 16 (declaration -> DOUBLE ID SEMICOLON .)
    IF              reduce using rule 16 (declaration -> DOUBLE ID SEMICOLON .)
    FOR             reduce using rule 16 (declaration -> DOUBLE ID SEMICOLON .)
    LBRACE          reduce using rule 16 (declaration -> DOUBLE ID SEMICOLON .)
    INT             reduce using rule 16 (declaration -> DOUBLE ID SEMICOLON .)
    FLOAT           reduce using rule 16 (declaration -> DOUBLE ID SEMICOLON .)
    CHAR            reduce using rule 16 (declaration -> DOUBLE ID SEMICOLON .)
    DOUBLE          reduce using rule 16 (declaration -> DOUBLE ID SEMICOLON .)
    VOID            reduce using rule 16 (declaration -> DOUBLE ID SEMICOLON .)
    $end            reduce using rule 16 (declaration -> DOUBLE ID SEMICOLON .)
    RBRACE          reduce using rule 16 (declaration -> DOUBLE ID SEMICOLON .)
    ELSE            reduce using rule 16 (declaration -> DOUBLE ID SEMICOLON .)


state 54

    (21) declaration -> DOUBLE ID ASSIGN . expression SEMICOLON
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    expression                     shift and go to state 76

state 55

    (17) declaration -> VOID ID SEMICOLON .

    ID              reduce using rule 17 (declaration -> VOID ID SEMICOLON .)
    IF              reduce using rule 17 (declaration -> VOID ID SEMICOLON .)
    FOR             reduce using rule 17 (declaration -> VOID ID SEMICOLON .)
    LBRACE          reduce using rule 17 (declaration -> VOID ID SEMICOLON .)
    INT             reduce using rule 17 (declaration -> VOID ID SEMICOLON .)
    FLOAT           reduce using rule 17 (declaration -> VOID ID SEMICOLON .)
    CHAR            reduce using rule 17 (declaration -> VOID ID SEMICOLON .)
    DOUBLE          reduce using rule 17 (declaration -> VOID ID SEMICOLON .)
    VOID            reduce using rule 17 (declaration -> VOID ID SEMICOLON .)
    $end            reduce using rule 17 (declaration -> VOID ID SEMICOLON .)
    RBRACE          reduce using rule 17 (declaration -> VOID ID SEMICOLON .)
    ELSE            reduce using rule 17 (declaration -> VOID ID SEMICOLON .)


state 56

    (22) assignment -> ID ASSIGN expression SEMICOLON .

    ID              reduce using rule 22 (assignment -> ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 22 (assignment -> ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 22 (assignment -> ID ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 22 (assignment -> ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 22 (assignment -> ID ASSIGN expression SEMICOLON .)
    FLOAT           reduce using rule 22 (assignment -> ID ASSIGN expression SEMICOLON .)
    CHAR            reduce using rule 22 (assignment -> ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 22 (assignment -> ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 22 (assignment -> ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 22 (assignment -> ID ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 22 (assignment -> ID ASSIGN expression SEMICOLON .)
    ELSE            reduce using rule 22 (assignment -> ID ASSIGN expression SEMICOLON .)


state 57

    (34) expression -> expression PLUS . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    expression                     shift and go to state 77

state 58

    (35) expression -> expression MINUS . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    expression                     shift and go to state 78

state 59

    (36) expression -> expression TIMES . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    expression                     shift and go to state 79

state 60

    (37) expression -> expression DIVIDE . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    expression                     shift and go to state 80

state 61

    (38) expression -> expression MODULO . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    expression                     shift and go to state 81

state 62

    (39) expression -> MINUS expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . MODULO expression

    SEMICOLON       reduce using rule 39 (expression -> MINUS expression .)
    PLUS            reduce using rule 39 (expression -> MINUS expression .)
    MINUS           reduce using rule 39 (expression -> MINUS expression .)
    TIMES           reduce using rule 39 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 39 (expression -> MINUS expression .)
    MODULO          reduce using rule 39 (expression -> MINUS expression .)
    LT              reduce using rule 39 (expression -> MINUS expression .)
    LE              reduce using rule 39 (expression -> MINUS expression .)
    GT              reduce using rule 39 (expression -> MINUS expression .)
    GE              reduce using rule 39 (expression -> MINUS expression .)
    EQ              reduce using rule 39 (expression -> MINUS expression .)
    NE              reduce using rule 39 (expression -> MINUS expression .)
    RPAREN          reduce using rule 39 (expression -> MINUS expression .)

  ! PLUS            [ shift and go to state 57 ]
  ! MINUS           [ shift and go to state 58 ]
  ! TIMES           [ shift and go to state 59 ]
  ! DIVIDE          [ shift and go to state 60 ]
  ! MODULO          [ shift and go to state 61 ]


state 63

    (43) expression -> LPAREN expression . RPAREN
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . MODULO expression

    RPAREN          shift and go to state 82
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    MODULO          shift and go to state 61


state 64

    (23) if_statement -> IF LPAREN condition RPAREN . statement
    (24) if_statement -> IF LPAREN condition RPAREN . statement ELSE statement
    (4) statement -> . assignment
    (5) statement -> . if_statement
    (6) statement -> . for_statement
    (7) statement -> . block
    (8) statement -> . declaration
    (9) statement -> . increment_statement
    (10) statement -> . decrement_statement
    (22) assignment -> . ID ASSIGN expression SEMICOLON
    (23) if_statement -> . IF LPAREN condition RPAREN statement
    (24) if_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (25) for_statement -> . FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement
    (33) block -> . LBRACE statement_list RBRACE
    (13) declaration -> . INT ID SEMICOLON
    (14) declaration -> . FLOAT ID SEMICOLON
    (15) declaration -> . CHAR ID SEMICOLON
    (16) declaration -> . DOUBLE ID SEMICOLON
    (17) declaration -> . VOID ID SEMICOLON
    (18) declaration -> . INT ID ASSIGN expression SEMICOLON
    (19) declaration -> . FLOAT ID ASSIGN expression SEMICOLON
    (20) declaration -> . CHAR ID ASSIGN expression SEMICOLON
    (21) declaration -> . DOUBLE ID ASSIGN expression SEMICOLON
    (11) increment_statement -> . ID INCREMENT SEMICOLON
    (12) decrement_statement -> . ID DECREMENT SEMICOLON

    ID              shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    LBRACE          shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    DOUBLE          shift and go to state 18
    VOID            shift and go to state 19

    statement                      shift and go to state 83
    assignment                     shift and go to state 4
    if_statement                   shift and go to state 5
    for_statement                  shift and go to state 6
    block                          shift and go to state 7
    declaration                    shift and go to state 8
    increment_statement            shift and go to state 9
    decrement_statement            shift and go to state 10

state 65

    (44) condition -> expression LT . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    expression                     shift and go to state 84

state 66

    (45) condition -> expression LE . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    expression                     shift and go to state 85

state 67

    (46) condition -> expression GT . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    expression                     shift and go to state 86

state 68

    (47) condition -> expression GE . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    expression                     shift and go to state 87

state 69

    (48) condition -> expression EQ . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    expression                     shift and go to state 88

state 70

    (49) condition -> expression NE . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    expression                     shift and go to state 89

state 71

    (25) for_statement -> FOR LPAREN for_init SEMICOLON . condition SEMICOLON for_increment RPAREN statement
    (44) condition -> . expression LT expression
    (45) condition -> . expression LE expression
    (46) condition -> . expression GT expression
    (47) condition -> . expression GE expression
    (48) condition -> . expression EQ expression
    (49) condition -> . expression NE expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    condition                      shift and go to state 90
    expression                     shift and go to state 41

state 72

    (28) assignment_no_semicolon -> ID ASSIGN . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    expression                     shift and go to state 91

state 73

    (18) declaration -> INT ID ASSIGN expression . SEMICOLON
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . MODULO expression

    SEMICOLON       shift and go to state 92
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    MODULO          shift and go to state 61


state 74

    (19) declaration -> FLOAT ID ASSIGN expression . SEMICOLON
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . MODULO expression

    SEMICOLON       shift and go to state 93
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    MODULO          shift and go to state 61


state 75

    (20) declaration -> CHAR ID ASSIGN expression . SEMICOLON
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . MODULO expression

    SEMICOLON       shift and go to state 94
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    MODULO          shift and go to state 61


state 76

    (21) declaration -> DOUBLE ID ASSIGN expression . SEMICOLON
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . MODULO expression

    SEMICOLON       shift and go to state 95
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    MODULO          shift and go to state 61


state 77

    (34) expression -> expression PLUS expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . MODULO expression

    SEMICOLON       reduce using rule 34 (expression -> expression PLUS expression .)
    PLUS            reduce using rule 34 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 34 (expression -> expression PLUS expression .)
    LT              reduce using rule 34 (expression -> expression PLUS expression .)
    LE              reduce using rule 34 (expression -> expression PLUS expression .)
    GT              reduce using rule 34 (expression -> expression PLUS expression .)
    GE              reduce using rule 34 (expression -> expression PLUS expression .)
    EQ              reduce using rule 34 (expression -> expression PLUS expression .)
    NE              reduce using rule 34 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 34 (expression -> expression PLUS expression .)
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    MODULO          shift and go to state 61

  ! TIMES           [ reduce using rule 34 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 34 (expression -> expression PLUS expression .) ]
  ! MODULO          [ reduce using rule 34 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 57 ]
  ! MINUS           [ shift and go to state 58 ]


state 78

    (35) expression -> expression MINUS expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . MODULO expression

    SEMICOLON       reduce using rule 35 (expression -> expression MINUS expression .)
    PLUS            reduce using rule 35 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 35 (expression -> expression MINUS expression .)
    LT              reduce using rule 35 (expression -> expression MINUS expression .)
    LE              reduce using rule 35 (expression -> expression MINUS expression .)
    GT              reduce using rule 35 (expression -> expression MINUS expression .)
    GE              reduce using rule 35 (expression -> expression MINUS expression .)
    EQ              reduce using rule 35 (expression -> expression MINUS expression .)
    NE              reduce using rule 35 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 35 (expression -> expression MINUS expression .)
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    MODULO          shift and go to state 61

  ! TIMES           [ reduce using rule 35 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 35 (expression -> expression MINUS expression .) ]
  ! MODULO          [ reduce using rule 35 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 57 ]
  ! MINUS           [ shift and go to state 58 ]


state 79

    (36) expression -> expression TIMES expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . MODULO expression

    SEMICOLON       reduce using rule 36 (expression -> expression TIMES expression .)
    PLUS            reduce using rule 36 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 36 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 36 (expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 36 (expression -> expression TIMES expression .)
    MODULO          reduce using rule 36 (expression -> expression TIMES expression .)
    LT              reduce using rule 36 (expression -> expression TIMES expression .)
    LE              reduce using rule 36 (expression -> expression TIMES expression .)
    GT              reduce using rule 36 (expression -> expression TIMES expression .)
    GE              reduce using rule 36 (expression -> expression TIMES expression .)
    EQ              reduce using rule 36 (expression -> expression TIMES expression .)
    NE              reduce using rule 36 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 36 (expression -> expression TIMES expression .)

  ! PLUS            [ shift and go to state 57 ]
  ! MINUS           [ shift and go to state 58 ]
  ! TIMES           [ shift and go to state 59 ]
  ! DIVIDE          [ shift and go to state 60 ]
  ! MODULO          [ shift and go to state 61 ]


state 80

    (37) expression -> expression DIVIDE expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . MODULO expression

    SEMICOLON       reduce using rule 37 (expression -> expression DIVIDE expression .)
    PLUS            reduce using rule 37 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 37 (expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 37 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 37 (expression -> expression DIVIDE expression .)
    MODULO          reduce using rule 37 (expression -> expression DIVIDE expression .)
    LT              reduce using rule 37 (expression -> expression DIVIDE expression .)
    LE              reduce using rule 37 (expression -> expression DIVIDE expression .)
    GT              reduce using rule 37 (expression -> expression DIVIDE expression .)
    GE              reduce using rule 37 (expression -> expression DIVIDE expression .)
    EQ              reduce using rule 37 (expression -> expression DIVIDE expression .)
    NE              reduce using rule 37 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 37 (expression -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 57 ]
  ! MINUS           [ shift and go to state 58 ]
  ! TIMES           [ shift and go to state 59 ]
  ! DIVIDE          [ shift and go to state 60 ]
  ! MODULO          [ shift and go to state 61 ]


state 81

    (38) expression -> expression MODULO expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . MODULO expression

    SEMICOLON       reduce using rule 38 (expression -> expression MODULO expression .)
    PLUS            reduce using rule 38 (expression -> expression MODULO expression .)
    MINUS           reduce using rule 38 (expression -> expression MODULO expression .)
    TIMES           reduce using rule 38 (expression -> expression MODULO expression .)
    DIVIDE          reduce using rule 38 (expression -> expression MODULO expression .)
    MODULO          reduce using rule 38 (expression -> expression MODULO expression .)
    LT              reduce using rule 38 (expression -> expression MODULO expression .)
    LE              reduce using rule 38 (expression -> expression MODULO expression .)
    GT              reduce using rule 38 (expression -> expression MODULO expression .)
    GE              reduce using rule 38 (expression -> expression MODULO expression .)
    EQ              reduce using rule 38 (expression -> expression MODULO expression .)
    NE              reduce using rule 38 (expression -> expression MODULO expression .)
    RPAREN          reduce using rule 38 (expression -> expression MODULO expression .)

  ! PLUS            [ shift and go to state 57 ]
  ! MINUS           [ shift and go to state 58 ]
  ! TIMES           [ shift and go to state 59 ]
  ! DIVIDE          [ shift and go to state 60 ]
  ! MODULO          [ shift and go to state 61 ]


state 82

    (43) expression -> LPAREN expression RPAREN .

    SEMICOLON       reduce using rule 43 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 43 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 43 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 43 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 43 (expression -> LPAREN expression RPAREN .)
    MODULO          reduce using rule 43 (expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 43 (expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 43 (expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 43 (expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 43 (expression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 43 (expression -> LPAREN expression RPAREN .)
    NE              reduce using rule 43 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 43 (expression -> LPAREN expression RPAREN .)


state 83

    (23) if_statement -> IF LPAREN condition RPAREN statement .
    (24) if_statement -> IF LPAREN condition RPAREN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    ID              reduce using rule 23 (if_statement -> IF LPAREN condition RPAREN statement .)
    IF              reduce using rule 23 (if_statement -> IF LPAREN condition RPAREN statement .)
    FOR             reduce using rule 23 (if_statement -> IF LPAREN condition RPAREN statement .)
    LBRACE          reduce using rule 23 (if_statement -> IF LPAREN condition RPAREN statement .)
    INT             reduce using rule 23 (if_statement -> IF LPAREN condition RPAREN statement .)
    FLOAT           reduce using rule 23 (if_statement -> IF LPAREN condition RPAREN statement .)
    CHAR            reduce using rule 23 (if_statement -> IF LPAREN condition RPAREN statement .)
    DOUBLE          reduce using rule 23 (if_statement -> IF LPAREN condition RPAREN statement .)
    VOID            reduce using rule 23 (if_statement -> IF LPAREN condition RPAREN statement .)
    $end            reduce using rule 23 (if_statement -> IF LPAREN condition RPAREN statement .)
    RBRACE          reduce using rule 23 (if_statement -> IF LPAREN condition RPAREN statement .)
    ELSE            shift and go to state 96

  ! ELSE            [ reduce using rule 23 (if_statement -> IF LPAREN condition RPAREN statement .) ]


state 84

    (44) condition -> expression LT expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . MODULO expression

    RPAREN          reduce using rule 44 (condition -> expression LT expression .)
    SEMICOLON       reduce using rule 44 (condition -> expression LT expression .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    MODULO          shift and go to state 61


state 85

    (45) condition -> expression LE expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . MODULO expression

    RPAREN          reduce using rule 45 (condition -> expression LE expression .)
    SEMICOLON       reduce using rule 45 (condition -> expression LE expression .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    MODULO          shift and go to state 61


state 86

    (46) condition -> expression GT expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . MODULO expression

    RPAREN          reduce using rule 46 (condition -> expression GT expression .)
    SEMICOLON       reduce using rule 46 (condition -> expression GT expression .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    MODULO          shift and go to state 61


state 87

    (47) condition -> expression GE expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . MODULO expression

    RPAREN          reduce using rule 47 (condition -> expression GE expression .)
    SEMICOLON       reduce using rule 47 (condition -> expression GE expression .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    MODULO          shift and go to state 61


state 88

    (48) condition -> expression EQ expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . MODULO expression

    RPAREN          reduce using rule 48 (condition -> expression EQ expression .)
    SEMICOLON       reduce using rule 48 (condition -> expression EQ expression .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    MODULO          shift and go to state 61


state 89

    (49) condition -> expression NE expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . MODULO expression

    RPAREN          reduce using rule 49 (condition -> expression NE expression .)
    SEMICOLON       reduce using rule 49 (condition -> expression NE expression .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    MODULO          shift and go to state 61


state 90

    (25) for_statement -> FOR LPAREN for_init SEMICOLON condition . SEMICOLON for_increment RPAREN statement

    SEMICOLON       shift and go to state 97


state 91

    (28) assignment_no_semicolon -> ID ASSIGN expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . MODULO expression

    SEMICOLON       reduce using rule 28 (assignment_no_semicolon -> ID ASSIGN expression .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    MODULO          shift and go to state 61


state 92

    (18) declaration -> INT ID ASSIGN expression SEMICOLON .

    ID              reduce using rule 18 (declaration -> INT ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 18 (declaration -> INT ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 18 (declaration -> INT ID ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 18 (declaration -> INT ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 18 (declaration -> INT ID ASSIGN expression SEMICOLON .)
    FLOAT           reduce using rule 18 (declaration -> INT ID ASSIGN expression SEMICOLON .)
    CHAR            reduce using rule 18 (declaration -> INT ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 18 (declaration -> INT ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 18 (declaration -> INT ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 18 (declaration -> INT ID ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 18 (declaration -> INT ID ASSIGN expression SEMICOLON .)
    ELSE            reduce using rule 18 (declaration -> INT ID ASSIGN expression SEMICOLON .)


state 93

    (19) declaration -> FLOAT ID ASSIGN expression SEMICOLON .

    ID              reduce using rule 19 (declaration -> FLOAT ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 19 (declaration -> FLOAT ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 19 (declaration -> FLOAT ID ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 19 (declaration -> FLOAT ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 19 (declaration -> FLOAT ID ASSIGN expression SEMICOLON .)
    FLOAT           reduce using rule 19 (declaration -> FLOAT ID ASSIGN expression SEMICOLON .)
    CHAR            reduce using rule 19 (declaration -> FLOAT ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 19 (declaration -> FLOAT ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 19 (declaration -> FLOAT ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 19 (declaration -> FLOAT ID ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 19 (declaration -> FLOAT ID ASSIGN expression SEMICOLON .)
    ELSE            reduce using rule 19 (declaration -> FLOAT ID ASSIGN expression SEMICOLON .)


state 94

    (20) declaration -> CHAR ID ASSIGN expression SEMICOLON .

    ID              reduce using rule 20 (declaration -> CHAR ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 20 (declaration -> CHAR ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 20 (declaration -> CHAR ID ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 20 (declaration -> CHAR ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 20 (declaration -> CHAR ID ASSIGN expression SEMICOLON .)
    FLOAT           reduce using rule 20 (declaration -> CHAR ID ASSIGN expression SEMICOLON .)
    CHAR            reduce using rule 20 (declaration -> CHAR ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 20 (declaration -> CHAR ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 20 (declaration -> CHAR ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 20 (declaration -> CHAR ID ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 20 (declaration -> CHAR ID ASSIGN expression SEMICOLON .)
    ELSE            reduce using rule 20 (declaration -> CHAR ID ASSIGN expression SEMICOLON .)


state 95

    (21) declaration -> DOUBLE ID ASSIGN expression SEMICOLON .

    ID              reduce using rule 21 (declaration -> DOUBLE ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 21 (declaration -> DOUBLE ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 21 (declaration -> DOUBLE ID ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 21 (declaration -> DOUBLE ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 21 (declaration -> DOUBLE ID ASSIGN expression SEMICOLON .)
    FLOAT           reduce using rule 21 (declaration -> DOUBLE ID ASSIGN expression SEMICOLON .)
    CHAR            reduce using rule 21 (declaration -> DOUBLE ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 21 (declaration -> DOUBLE ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 21 (declaration -> DOUBLE ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 21 (declaration -> DOUBLE ID ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 21 (declaration -> DOUBLE ID ASSIGN expression SEMICOLON .)
    ELSE            reduce using rule 21 (declaration -> DOUBLE ID ASSIGN expression SEMICOLON .)


state 96

    (24) if_statement -> IF LPAREN condition RPAREN statement ELSE . statement
    (4) statement -> . assignment
    (5) statement -> . if_statement
    (6) statement -> . for_statement
    (7) statement -> . block
    (8) statement -> . declaration
    (9) statement -> . increment_statement
    (10) statement -> . decrement_statement
    (22) assignment -> . ID ASSIGN expression SEMICOLON
    (23) if_statement -> . IF LPAREN condition RPAREN statement
    (24) if_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (25) for_statement -> . FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement
    (33) block -> . LBRACE statement_list RBRACE
    (13) declaration -> . INT ID SEMICOLON
    (14) declaration -> . FLOAT ID SEMICOLON
    (15) declaration -> . CHAR ID SEMICOLON
    (16) declaration -> . DOUBLE ID SEMICOLON
    (17) declaration -> . VOID ID SEMICOLON
    (18) declaration -> . INT ID ASSIGN expression SEMICOLON
    (19) declaration -> . FLOAT ID ASSIGN expression SEMICOLON
    (20) declaration -> . CHAR ID ASSIGN expression SEMICOLON
    (21) declaration -> . DOUBLE ID ASSIGN expression SEMICOLON
    (11) increment_statement -> . ID INCREMENT SEMICOLON
    (12) decrement_statement -> . ID DECREMENT SEMICOLON

    ID              shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    LBRACE          shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    DOUBLE          shift and go to state 18
    VOID            shift and go to state 19

    statement                      shift and go to state 98
    assignment                     shift and go to state 4
    if_statement                   shift and go to state 5
    for_statement                  shift and go to state 6
    block                          shift and go to state 7
    declaration                    shift and go to state 8
    increment_statement            shift and go to state 9
    decrement_statement            shift and go to state 10

state 97

    (25) for_statement -> FOR LPAREN for_init SEMICOLON condition SEMICOLON . for_increment RPAREN statement
    (30) for_increment -> . ID ASSIGN expression
    (31) for_increment -> . ID INCREMENT
    (32) for_increment -> . ID DECREMENT

    ID              shift and go to state 100

    for_increment                  shift and go to state 99

state 98

    (24) if_statement -> IF LPAREN condition RPAREN statement ELSE statement .

    ID              reduce using rule 24 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    IF              reduce using rule 24 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    FOR             reduce using rule 24 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    LBRACE          reduce using rule 24 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    INT             reduce using rule 24 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    FLOAT           reduce using rule 24 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    CHAR            reduce using rule 24 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    DOUBLE          reduce using rule 24 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    VOID            reduce using rule 24 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    $end            reduce using rule 24 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    RBRACE          reduce using rule 24 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    ELSE            reduce using rule 24 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)


state 99

    (25) for_statement -> FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment . RPAREN statement

    RPAREN          shift and go to state 101


state 100

    (30) for_increment -> ID . ASSIGN expression
    (31) for_increment -> ID . INCREMENT
    (32) for_increment -> ID . DECREMENT

    ASSIGN          shift and go to state 102
    INCREMENT       shift and go to state 103
    DECREMENT       shift and go to state 104


state 101

    (25) for_statement -> FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN . statement
    (4) statement -> . assignment
    (5) statement -> . if_statement
    (6) statement -> . for_statement
    (7) statement -> . block
    (8) statement -> . declaration
    (9) statement -> . increment_statement
    (10) statement -> . decrement_statement
    (22) assignment -> . ID ASSIGN expression SEMICOLON
    (23) if_statement -> . IF LPAREN condition RPAREN statement
    (24) if_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (25) for_statement -> . FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement
    (33) block -> . LBRACE statement_list RBRACE
    (13) declaration -> . INT ID SEMICOLON
    (14) declaration -> . FLOAT ID SEMICOLON
    (15) declaration -> . CHAR ID SEMICOLON
    (16) declaration -> . DOUBLE ID SEMICOLON
    (17) declaration -> . VOID ID SEMICOLON
    (18) declaration -> . INT ID ASSIGN expression SEMICOLON
    (19) declaration -> . FLOAT ID ASSIGN expression SEMICOLON
    (20) declaration -> . CHAR ID ASSIGN expression SEMICOLON
    (21) declaration -> . DOUBLE ID ASSIGN expression SEMICOLON
    (11) increment_statement -> . ID INCREMENT SEMICOLON
    (12) decrement_statement -> . ID DECREMENT SEMICOLON

    ID              shift and go to state 11
    IF              shift and go to state 12
    FOR             shift and go to state 13
    LBRACE          shift and go to state 14
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    DOUBLE          shift and go to state 18
    VOID            shift and go to state 19

    statement                      shift and go to state 105
    assignment                     shift and go to state 4
    if_statement                   shift and go to state 5
    for_statement                  shift and go to state 6
    block                          shift and go to state 7
    declaration                    shift and go to state 8
    increment_statement            shift and go to state 9
    decrement_statement            shift and go to state 10

state 102

    (30) for_increment -> ID ASSIGN . expression
    (34) expression -> . expression PLUS expression
    (35) expression -> . expression MINUS expression
    (36) expression -> . expression TIMES expression
    (37) expression -> . expression DIVIDE expression
    (38) expression -> . expression MODULO expression
    (39) expression -> . MINUS expression
    (40) expression -> . ID
    (41) expression -> . CONSTANT
    (42) expression -> . FLOAT_CONSTANT
    (43) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 34
    ID              shift and go to state 32
    CONSTANT        shift and go to state 35
    FLOAT_CONSTANT  shift and go to state 36
    LPAREN          shift and go to state 37

    expression                     shift and go to state 106

state 103

    (31) for_increment -> ID INCREMENT .

    RPAREN          reduce using rule 31 (for_increment -> ID INCREMENT .)


state 104

    (32) for_increment -> ID DECREMENT .

    RPAREN          reduce using rule 32 (for_increment -> ID DECREMENT .)


state 105

    (25) for_statement -> FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement .

    ID              reduce using rule 25 (for_statement -> FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement .)
    IF              reduce using rule 25 (for_statement -> FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement .)
    FOR             reduce using rule 25 (for_statement -> FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement .)
    LBRACE          reduce using rule 25 (for_statement -> FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement .)
    INT             reduce using rule 25 (for_statement -> FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement .)
    FLOAT           reduce using rule 25 (for_statement -> FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement .)
    CHAR            reduce using rule 25 (for_statement -> FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement .)
    DOUBLE          reduce using rule 25 (for_statement -> FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement .)
    VOID            reduce using rule 25 (for_statement -> FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement .)
    $end            reduce using rule 25 (for_statement -> FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement .)
    RBRACE          reduce using rule 25 (for_statement -> FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement .)
    ELSE            reduce using rule 25 (for_statement -> FOR LPAREN for_init SEMICOLON condition SEMICOLON for_increment RPAREN statement .)


state 106

    (30) for_increment -> ID ASSIGN expression .
    (34) expression -> expression . PLUS expression
    (35) expression -> expression . MINUS expression
    (36) expression -> expression . TIMES expression
    (37) expression -> expression . DIVIDE expression
    (38) expression -> expression . MODULO expression

    RPAREN          reduce using rule 30 (for_increment -> ID ASSIGN expression .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    MODULO          shift and go to state 61

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 83 resolved as shift

Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AUTO
    BREAK
    CASE
    COMMA
    CONST
    CONTINUE
    DEFAULT
    DO
    ENUM
    EXTERN
    GOTO
    LBRACKET
    LONG
    RBRACKET
    REGISTER
    RETURN
    SHORT
    SIGNED
    SIZEOF
    STATIC
    STRING
    STRUCT
    SWITCH
    TYPEDEF
    UNION
    UNSIGNED
    VOLATILE
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement_list statement
Rule 3     statement_list -> statement
Rule 4     statement -> assignment
Rule 5     statement -> if_statement
Rule 6     statement -> for_statement
Rule 7     statement -> block
Rule 8     statement -> declaration
Rule 9     declaration -> INT ID SEMICOLON
Rule 10    declaration -> FLOAT ID SEMICOLON
Rule 11    declaration -> CHAR ID SEMICOLON
Rule 12    declaration -> DOUBLE ID SEMICOLON
Rule 13    declaration -> VOID ID SEMICOLON
Rule 14    assignment -> ID ASSIGN expression SEMICOLON
Rule 15    if_statement -> IF LPAREN condition RPAREN statement
Rule 16    if_statement -> IF LPAREN condition RPAREN statement ELSE statement
Rule 17    for_statement -> FOR LPAREN assignment condition SEMICOLON for_increment RPAREN statement
Rule 18    for_increment -> ID ASSIGN expression
Rule 19    block -> LBRACE statement_list RBRACE
Rule 20    expression -> expression PLUS expression
Rule 21    expression -> expression MINUS expression
Rule 22    expression -> expression TIMES expression
Rule 23    expression -> expression DIVIDE expression
Rule 24    expression -> expression MODULO expression
Rule 25    expression -> MINUS expression
Rule 26    expression -> ID
Rule 27    expression -> CONSTANT
Rule 28    expression -> FLOAT_CONSTANT
Rule 29    expression -> LPAREN expression RPAREN
Rule 30    condition -> expression LT expression
Rule 31    condition -> expression LE expression
Rule 32    condition -> expression GT expression
Rule 33    condition -> expression GE expression
Rule 34    condition -> expression EQ expression
Rule 35    condition -> expression NE expression

Terminals, with rules where they appear

ASSIGN               : 14 18
AUTO                 : 
BREAK                : 
CASE                 : 
CHAR                 : 11
COMMA                : 
CONST                : 
CONSTANT             : 27
CONTINUE             : 
DEFAULT              : 
DIVIDE               : 23
DO                   : 
DOUBLE               : 12
ELSE                 : 16
ENUM                 : 
EQ                   : 34
EXTERN               : 
FLOAT                : 10
FLOAT_CONSTANT       : 28
FOR                  : 17
GE                   : 33
GOTO                 : 
GT                   : 32
ID                   : 9 10 11 12 13 14 18 26
IF                   : 15 16
INT                  : 9
LBRACE               : 19
LBRACKET             : 
LE                   : 31
LONG                 : 
LPAREN               : 15 16 17 29
LT                   : 30
MINUS                : 21 25
MODULO               : 24
NE                   : 35
PLUS                 : 20
RBRACE               : 19
RBRACKET             : 
REGISTER             : 
RETURN               : 
RPAREN               : 15 16 17 29
SEMICOLON            : 9 10 11 12 13 14 17
SHORT                : 
SIGNED               : 
SIZEOF               : 
STATIC               : 
STRING               : 
STRUCT               : 
SWITCH               : 
TIMES                : 22
TYPEDEF              : 
UNION                : 
UNSIGNED             : 
VOID                 : 13
VOLATILE             : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

assignment           : 4 17
block                : 7
condition            : 15 16 17
declaration          : 8
expression           : 14 18 20 20 21 21 22 22 23 23 24 24 25 29 30 30 31 31 32 32 33 33 34 34 35 35
for_increment        : 17
for_statement        : 6
if_statement         : 5
program              : 0
statement            : 2 3 15 16 16 17
statement_list       : 1 2 19

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . assignment
    (5) statement -> . if_statement
    (6) statement -> . for_statement
    (7) statement -> . block
    (8) statement -> . declaration
    (14) assignment -> . ID ASSIGN expression SEMICOLON
    (15) if_statement -> . IF LPAREN condition RPAREN statement
    (16) if_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (17) for_statement -> . FOR LPAREN assignment condition SEMICOLON for_increment RPAREN statement
    (19) block -> . LBRACE statement_list RBRACE
    (9) declaration -> . INT ID SEMICOLON
    (10) declaration -> . FLOAT ID SEMICOLON
    (11) declaration -> . CHAR ID SEMICOLON
    (12) declaration -> . DOUBLE ID SEMICOLON
    (13) declaration -> . VOID ID SEMICOLON

    ID              shift and go to state 9
    IF              shift and go to state 10
    FOR             shift and go to state 11
    LBRACE          shift and go to state 12
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 15
    DOUBLE          shift and go to state 16
    VOID            shift and go to state 17

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    if_statement                   shift and go to state 5
    for_statement                  shift and go to state 6
    block                          shift and go to state 7
    declaration                    shift and go to state 8

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .
    (2) statement_list -> statement_list . statement
    (4) statement -> . assignment
    (5) statement -> . if_statement
    (6) statement -> . for_statement
    (7) statement -> . block
    (8) statement -> . declaration
    (14) assignment -> . ID ASSIGN expression SEMICOLON
    (15) if_statement -> . IF LPAREN condition RPAREN statement
    (16) if_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (17) for_statement -> . FOR LPAREN assignment condition SEMICOLON for_increment RPAREN statement
    (19) block -> . LBRACE statement_list RBRACE
    (9) declaration -> . INT ID SEMICOLON
    (10) declaration -> . FLOAT ID SEMICOLON
    (11) declaration -> . CHAR ID SEMICOLON
    (12) declaration -> . DOUBLE ID SEMICOLON
    (13) declaration -> . VOID ID SEMICOLON

    $end            reduce using rule 1 (program -> statement_list .)
    ID              shift and go to state 9
    IF              shift and go to state 10
    FOR             shift and go to state 11
    LBRACE          shift and go to state 12
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 15
    DOUBLE          shift and go to state 16
    VOID            shift and go to state 17

    statement                      shift and go to state 18
    assignment                     shift and go to state 4
    if_statement                   shift and go to state 5
    for_statement                  shift and go to state 6
    block                          shift and go to state 7
    declaration                    shift and go to state 8

state 3

    (3) statement_list -> statement .

    ID              reduce using rule 3 (statement_list -> statement .)
    IF              reduce using rule 3 (statement_list -> statement .)
    FOR             reduce using rule 3 (statement_list -> statement .)
    LBRACE          reduce using rule 3 (statement_list -> statement .)
    INT             reduce using rule 3 (statement_list -> statement .)
    FLOAT           reduce using rule 3 (statement_list -> statement .)
    CHAR            reduce using rule 3 (statement_list -> statement .)
    DOUBLE          reduce using rule 3 (statement_list -> statement .)
    VOID            reduce using rule 3 (statement_list -> statement .)
    $end            reduce using rule 3 (statement_list -> statement .)
    RBRACE          reduce using rule 3 (statement_list -> statement .)


state 4

    (4) statement -> assignment .

    ID              reduce using rule 4 (statement -> assignment .)
    IF              reduce using rule 4 (statement -> assignment .)
    FOR             reduce using rule 4 (statement -> assignment .)
    LBRACE          reduce using rule 4 (statement -> assignment .)
    INT             reduce using rule 4 (statement -> assignment .)
    FLOAT           reduce using rule 4 (statement -> assignment .)
    CHAR            reduce using rule 4 (statement -> assignment .)
    DOUBLE          reduce using rule 4 (statement -> assignment .)
    VOID            reduce using rule 4 (statement -> assignment .)
    $end            reduce using rule 4 (statement -> assignment .)
    RBRACE          reduce using rule 4 (statement -> assignment .)
    ELSE            reduce using rule 4 (statement -> assignment .)


state 5

    (5) statement -> if_statement .

    ID              reduce using rule 5 (statement -> if_statement .)
    IF              reduce using rule 5 (statement -> if_statement .)
    FOR             reduce using rule 5 (statement -> if_statement .)
    LBRACE          reduce using rule 5 (statement -> if_statement .)
    INT             reduce using rule 5 (statement -> if_statement .)
    FLOAT           reduce using rule 5 (statement -> if_statement .)
    CHAR            reduce using rule 5 (statement -> if_statement .)
    DOUBLE          reduce using rule 5 (statement -> if_statement .)
    VOID            reduce using rule 5 (statement -> if_statement .)
    $end            reduce using rule 5 (statement -> if_statement .)
    RBRACE          reduce using rule 5 (statement -> if_statement .)
    ELSE            reduce using rule 5 (statement -> if_statement .)


state 6

    (6) statement -> for_statement .

    ID              reduce using rule 6 (statement -> for_statement .)
    IF              reduce using rule 6 (statement -> for_statement .)
    FOR             reduce using rule 6 (statement -> for_statement .)
    LBRACE          reduce using rule 6 (statement -> for_statement .)
    INT             reduce using rule 6 (statement -> for_statement .)
    FLOAT           reduce using rule 6 (statement -> for_statement .)
    CHAR            reduce using rule 6 (statement -> for_statement .)
    DOUBLE          reduce using rule 6 (statement -> for_statement .)
    VOID            reduce using rule 6 (statement -> for_statement .)
    $end            reduce using rule 6 (statement -> for_statement .)
    RBRACE          reduce using rule 6 (statement -> for_statement .)
    ELSE            reduce using rule 6 (statement -> for_statement .)


state 7

    (7) statement -> block .

    ID              reduce using rule 7 (statement -> block .)
    IF              reduce using rule 7 (statement -> block .)
    FOR             reduce using rule 7 (statement -> block .)
    LBRACE          reduce using rule 7 (statement -> block .)
    INT             reduce using rule 7 (statement -> block .)
    FLOAT           reduce using rule 7 (statement -> block .)
    CHAR            reduce using rule 7 (statement -> block .)
    DOUBLE          reduce using rule 7 (statement -> block .)
    VOID            reduce using rule 7 (statement -> block .)
    $end            reduce using rule 7 (statement -> block .)
    RBRACE          reduce using rule 7 (statement -> block .)
    ELSE            reduce using rule 7 (statement -> block .)


state 8

    (8) statement -> declaration .

    ID              reduce using rule 8 (statement -> declaration .)
    IF              reduce using rule 8 (statement -> declaration .)
    FOR             reduce using rule 8 (statement -> declaration .)
    LBRACE          reduce using rule 8 (statement -> declaration .)
    INT             reduce using rule 8 (statement -> declaration .)
    FLOAT           reduce using rule 8 (statement -> declaration .)
    CHAR            reduce using rule 8 (statement -> declaration .)
    DOUBLE          reduce using rule 8 (statement -> declaration .)
    VOID            reduce using rule 8 (statement -> declaration .)
    $end            reduce using rule 8 (statement -> declaration .)
    RBRACE          reduce using rule 8 (statement -> declaration .)
    ELSE            reduce using rule 8 (statement -> declaration .)


state 9

    (14) assignment -> ID . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 19


state 10

    (15) if_statement -> IF . LPAREN condition RPAREN statement
    (16) if_statement -> IF . LPAREN condition RPAREN statement ELSE statement

    LPAREN          shift and go to state 20


state 11

    (17) for_statement -> FOR . LPAREN assignment condition SEMICOLON for_increment RPAREN statement

    LPAREN          shift and go to state 21


state 12

    (19) block -> LBRACE . statement_list RBRACE
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . assignment
    (5) statement -> . if_statement
    (6) statement -> . for_statement
    (7) statement -> . block
    (8) statement -> . declaration
    (14) assignment -> . ID ASSIGN expression SEMICOLON
    (15) if_statement -> . IF LPAREN condition RPAREN statement
    (16) if_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (17) for_statement -> . FOR LPAREN assignment condition SEMICOLON for_increment RPAREN statement
    (19) block -> . LBRACE statement_list RBRACE
    (9) declaration -> . INT ID SEMICOLON
    (10) declaration -> . FLOAT ID SEMICOLON
    (11) declaration -> . CHAR ID SEMICOLON
    (12) declaration -> . DOUBLE ID SEMICOLON
    (13) declaration -> . VOID ID SEMICOLON

    ID              shift and go to state 9
    IF              shift and go to state 10
    FOR             shift and go to state 11
    LBRACE          shift and go to state 12
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 15
    DOUBLE          shift and go to state 16
    VOID            shift and go to state 17

    statement_list                 shift and go to state 22
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    if_statement                   shift and go to state 5
    for_statement                  shift and go to state 6
    block                          shift and go to state 7
    declaration                    shift and go to state 8

state 13

    (9) declaration -> INT . ID SEMICOLON

    ID              shift and go to state 23


state 14

    (10) declaration -> FLOAT . ID SEMICOLON

    ID              shift and go to state 24


state 15

    (11) declaration -> CHAR . ID SEMICOLON

    ID              shift and go to state 25


state 16

    (12) declaration -> DOUBLE . ID SEMICOLON

    ID              shift and go to state 26


state 17

    (13) declaration -> VOID . ID SEMICOLON

    ID              shift and go to state 27


state 18

    (2) statement_list -> statement_list statement .

    ID              reduce using rule 2 (statement_list -> statement_list statement .)
    IF              reduce using rule 2 (statement_list -> statement_list statement .)
    FOR             reduce using rule 2 (statement_list -> statement_list statement .)
    LBRACE          reduce using rule 2 (statement_list -> statement_list statement .)
    INT             reduce using rule 2 (statement_list -> statement_list statement .)
    FLOAT           reduce using rule 2 (statement_list -> statement_list statement .)
    CHAR            reduce using rule 2 (statement_list -> statement_list statement .)
    DOUBLE          reduce using rule 2 (statement_list -> statement_list statement .)
    VOID            reduce using rule 2 (statement_list -> statement_list statement .)
    $end            reduce using rule 2 (statement_list -> statement_list statement .)
    RBRACE          reduce using rule 2 (statement_list -> statement_list statement .)


state 19

    (14) assignment -> ID ASSIGN . expression SEMICOLON
    (20) expression -> . expression PLUS expression
    (21) expression -> . expression MINUS expression
    (22) expression -> . expression TIMES expression
    (23) expression -> . expression DIVIDE expression
    (24) expression -> . expression MODULO expression
    (25) expression -> . MINUS expression
    (26) expression -> . ID
    (27) expression -> . CONSTANT
    (28) expression -> . FLOAT_CONSTANT
    (29) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 30
    ID              shift and go to state 28
    CONSTANT        shift and go to state 31
    FLOAT_CONSTANT  shift and go to state 32
    LPAREN          shift and go to state 33

    expression                     shift and go to state 29

state 20

    (15) if_statement -> IF LPAREN . condition RPAREN statement
    (16) if_statement -> IF LPAREN . condition RPAREN statement ELSE statement
    (30) condition -> . expression LT expression
    (31) condition -> . expression LE expression
    (32) condition -> . expression GT expression
    (33) condition -> . expression GE expression
    (34) condition -> . expression EQ expression
    (35) condition -> . expression NE expression
    (20) expression -> . expression PLUS expression
    (21) expression -> . expression MINUS expression
    (22) expression -> . expression TIMES expression
    (23) expression -> . expression DIVIDE expression
    (24) expression -> . expression MODULO expression
    (25) expression -> . MINUS expression
    (26) expression -> . ID
    (27) expression -> . CONSTANT
    (28) expression -> . FLOAT_CONSTANT
    (29) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 30
    ID              shift and go to state 28
    CONSTANT        shift and go to state 31
    FLOAT_CONSTANT  shift and go to state 32
    LPAREN          shift and go to state 33

    condition                      shift and go to state 34
    expression                     shift and go to state 35

state 21

    (17) for_statement -> FOR LPAREN . assignment condition SEMICOLON for_increment RPAREN statement
    (14) assignment -> . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 9

    assignment                     shift and go to state 36

state 22

    (19) block -> LBRACE statement_list . RBRACE
    (2) statement_list -> statement_list . statement
    (4) statement -> . assignment
    (5) statement -> . if_statement
    (6) statement -> . for_statement
    (7) statement -> . block
    (8) statement -> . declaration
    (14) assignment -> . ID ASSIGN expression SEMICOLON
    (15) if_statement -> . IF LPAREN condition RPAREN statement
    (16) if_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (17) for_statement -> . FOR LPAREN assignment condition SEMICOLON for_increment RPAREN statement
    (19) block -> . LBRACE statement_list RBRACE
    (9) declaration -> . INT ID SEMICOLON
    (10) declaration -> . FLOAT ID SEMICOLON
    (11) declaration -> . CHAR ID SEMICOLON
    (12) declaration -> . DOUBLE ID SEMICOLON
    (13) declaration -> . VOID ID SEMICOLON

    RBRACE          shift and go to state 37
    ID              shift and go to state 9
    IF              shift and go to state 10
    FOR             shift and go to state 11
    LBRACE          shift and go to state 12
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 15
    DOUBLE          shift and go to state 16
    VOID            shift and go to state 17

    statement                      shift and go to state 18
    assignment                     shift and go to state 4
    if_statement                   shift and go to state 5
    for_statement                  shift and go to state 6
    block                          shift and go to state 7
    declaration                    shift and go to state 8

state 23

    (9) declaration -> INT ID . SEMICOLON

    SEMICOLON       shift and go to state 38


state 24

    (10) declaration -> FLOAT ID . SEMICOLON

    SEMICOLON       shift and go to state 39


state 25

    (11) declaration -> CHAR ID . SEMICOLON

    SEMICOLON       shift and go to state 40


state 26

    (12) declaration -> DOUBLE ID . SEMICOLON

    SEMICOLON       shift and go to state 41


state 27

    (13) declaration -> VOID ID . SEMICOLON

    SEMICOLON       shift and go to state 42


state 28

    (26) expression -> ID .

    SEMICOLON       reduce using rule 26 (expression -> ID .)
    PLUS            reduce using rule 26 (expression -> ID .)
    MINUS           reduce using rule 26 (expression -> ID .)
    TIMES           reduce using rule 26 (expression -> ID .)
    DIVIDE          reduce using rule 26 (expression -> ID .)
    MODULO          reduce using rule 26 (expression -> ID .)
    LT              reduce using rule 26 (expression -> ID .)
    LE              reduce using rule 26 (expression -> ID .)
    GT              reduce using rule 26 (expression -> ID .)
    GE              reduce using rule 26 (expression -> ID .)
    EQ              reduce using rule 26 (expression -> ID .)
    NE              reduce using rule 26 (expression -> ID .)
    RPAREN          reduce using rule 26 (expression -> ID .)


state 29

    (14) assignment -> ID ASSIGN expression . SEMICOLON
    (20) expression -> expression . PLUS expression
    (21) expression -> expression . MINUS expression
    (22) expression -> expression . TIMES expression
    (23) expression -> expression . DIVIDE expression
    (24) expression -> expression . MODULO expression

    SEMICOLON       shift and go to state 43
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULO          shift and go to state 48


state 30

    (25) expression -> MINUS . expression
    (20) expression -> . expression PLUS expression
    (21) expression -> . expression MINUS expression
    (22) expression -> . expression TIMES expression
    (23) expression -> . expression DIVIDE expression
    (24) expression -> . expression MODULO expression
    (25) expression -> . MINUS expression
    (26) expression -> . ID
    (27) expression -> . CONSTANT
    (28) expression -> . FLOAT_CONSTANT
    (29) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 30
    ID              shift and go to state 28
    CONSTANT        shift and go to state 31
    FLOAT_CONSTANT  shift and go to state 32
    LPAREN          shift and go to state 33

    expression                     shift and go to state 49

state 31

    (27) expression -> CONSTANT .

    SEMICOLON       reduce using rule 27 (expression -> CONSTANT .)
    PLUS            reduce using rule 27 (expression -> CONSTANT .)
    MINUS           reduce using rule 27 (expression -> CONSTANT .)
    TIMES           reduce using rule 27 (expression -> CONSTANT .)
    DIVIDE          reduce using rule 27 (expression -> CONSTANT .)
    MODULO          reduce using rule 27 (expression -> CONSTANT .)
    LT              reduce using rule 27 (expression -> CONSTANT .)
    LE              reduce using rule 27 (expression -> CONSTANT .)
    GT              reduce using rule 27 (expression -> CONSTANT .)
    GE              reduce using rule 27 (expression -> CONSTANT .)
    EQ              reduce using rule 27 (expression -> CONSTANT .)
    NE              reduce using rule 27 (expression -> CONSTANT .)
    RPAREN          reduce using rule 27 (expression -> CONSTANT .)


state 32

    (28) expression -> FLOAT_CONSTANT .

    SEMICOLON       reduce using rule 28 (expression -> FLOAT_CONSTANT .)
    PLUS            reduce using rule 28 (expression -> FLOAT_CONSTANT .)
    MINUS           reduce using rule 28 (expression -> FLOAT_CONSTANT .)
    TIMES           reduce using rule 28 (expression -> FLOAT_CONSTANT .)
    DIVIDE          reduce using rule 28 (expression -> FLOAT_CONSTANT .)
    MODULO          reduce using rule 28 (expression -> FLOAT_CONSTANT .)
    LT              reduce using rule 28 (expression -> FLOAT_CONSTANT .)
    LE              reduce using rule 28 (expression -> FLOAT_CONSTANT .)
    GT              reduce using rule 28 (expression -> FLOAT_CONSTANT .)
    GE              reduce using rule 28 (expression -> FLOAT_CONSTANT .)
    EQ              reduce using rule 28 (expression -> FLOAT_CONSTANT .)
    NE              reduce using rule 28 (expression -> FLOAT_CONSTANT .)
    RPAREN          reduce using rule 28 (expression -> FLOAT_CONSTANT .)


state 33

    (29) expression -> LPAREN . expression RPAREN
    (20) expression -> . expression PLUS expression
    (21) expression -> . expression MINUS expression
    (22) expression -> . expression TIMES expression
    (23) expression -> . expression DIVIDE expression
    (24) expression -> . expression MODULO expression
    (25) expression -> . MINUS expression
    (26) expression -> . ID
    (27) expression -> . CONSTANT
    (28) expression -> . FLOAT_CONSTANT
    (29) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 30
    ID              shift and go to state 28
    CONSTANT        shift and go to state 31
    FLOAT_CONSTANT  shift and go to state 32
    LPAREN          shift and go to state 33

    expression                     shift and go to state 50

state 34

    (15) if_statement -> IF LPAREN condition . RPAREN statement
    (16) if_statement -> IF LPAREN condition . RPAREN statement ELSE statement

    RPAREN          shift and go to state 51


state 35

    (30) condition -> expression . LT expression
    (31) condition -> expression . LE expression
    (32) condition -> expression . GT expression
    (33) condition -> expression . GE expression
    (34) condition -> expression . EQ expression
    (35) condition -> expression . NE expression
    (20) expression -> expression . PLUS expression
    (21) expression -> expression . MINUS expression
    (22) expression -> expression . TIMES expression
    (23) expression -> expression . DIVIDE expression
    (24) expression -> expression . MODULO expression

    LT              shift and go to state 52
    LE              shift and go to state 53
    GT              shift and go to state 54
    GE              shift and go to state 55
    EQ              shift and go to state 56
    NE              shift and go to state 57
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULO          shift and go to state 48


state 36

    (17) for_statement -> FOR LPAREN assignment . condition SEMICOLON for_increment RPAREN statement
    (30) condition -> . expression LT expression
    (31) condition -> . expression LE expression
    (32) condition -> . expression GT expression
    (33) condition -> . expression GE expression
    (34) condition -> . expression EQ expression
    (35) condition -> . expression NE expression
    (20) expression -> . expression PLUS expression
    (21) expression -> . expression MINUS expression
    (22) expression -> . expression TIMES expression
    (23) expression -> . expression DIVIDE expression
    (24) expression -> . expression MODULO expression
    (25) expression -> . MINUS expression
    (26) expression -> . ID
    (27) expression -> . CONSTANT
    (28) expression -> . FLOAT_CONSTANT
    (29) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 30
    ID              shift and go to state 28
    CONSTANT        shift and go to state 31
    FLOAT_CONSTANT  shift and go to state 32
    LPAREN          shift and go to state 33

    condition                      shift and go to state 58
    expression                     shift and go to state 35

state 37

    (19) block -> LBRACE statement_list RBRACE .

    ID              reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    IF              reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    FOR             reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    LBRACE          reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    INT             reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    FLOAT           reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    CHAR            reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    DOUBLE          reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    VOID            reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    $end            reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 19 (block -> LBRACE statement_list RBRACE .)
    ELSE            reduce using rule 19 (block -> LBRACE statement_list RBRACE .)


state 38

    (9) declaration -> INT ID SEMICOLON .

    ID              reduce using rule 9 (declaration -> INT ID SEMICOLON .)
    IF              reduce using rule 9 (declaration -> INT ID SEMICOLON .)
    FOR             reduce using rule 9 (declaration -> INT ID SEMICOLON .)
    LBRACE          reduce using rule 9 (declaration -> INT ID SEMICOLON .)
    INT             reduce using rule 9 (declaration -> INT ID SEMICOLON .)
    FLOAT           reduce using rule 9 (declaration -> INT ID SEMICOLON .)
    CHAR            reduce using rule 9 (declaration -> INT ID SEMICOLON .)
    DOUBLE          reduce using rule 9 (declaration -> INT ID SEMICOLON .)
    VOID            reduce using rule 9 (declaration -> INT ID SEMICOLON .)
    $end            reduce using rule 9 (declaration -> INT ID SEMICOLON .)
    RBRACE          reduce using rule 9 (declaration -> INT ID SEMICOLON .)
    ELSE            reduce using rule 9 (declaration -> INT ID SEMICOLON .)


state 39

    (10) declaration -> FLOAT ID SEMICOLON .

    ID              reduce using rule 10 (declaration -> FLOAT ID SEMICOLON .)
    IF              reduce using rule 10 (declaration -> FLOAT ID SEMICOLON .)
    FOR             reduce using rule 10 (declaration -> FLOAT ID SEMICOLON .)
    LBRACE          reduce using rule 10 (declaration -> FLOAT ID SEMICOLON .)
    INT             reduce using rule 10 (declaration -> FLOAT ID SEMICOLON .)
    FLOAT           reduce using rule 10 (declaration -> FLOAT ID SEMICOLON .)
    CHAR            reduce using rule 10 (declaration -> FLOAT ID SEMICOLON .)
    DOUBLE          reduce using rule 10 (declaration -> FLOAT ID SEMICOLON .)
    VOID            reduce using rule 10 (declaration -> FLOAT ID SEMICOLON .)
    $end            reduce using rule 10 (declaration -> FLOAT ID SEMICOLON .)
    RBRACE          reduce using rule 10 (declaration -> FLOAT ID SEMICOLON .)
    ELSE            reduce using rule 10 (declaration -> FLOAT ID SEMICOLON .)


state 40

    (11) declaration -> CHAR ID SEMICOLON .

    ID              reduce using rule 11 (declaration -> CHAR ID SEMICOLON .)
    IF              reduce using rule 11 (declaration -> CHAR ID SEMICOLON .)
    FOR             reduce using rule 11 (declaration -> CHAR ID SEMICOLON .)
    LBRACE          reduce using rule 11 (declaration -> CHAR ID SEMICOLON .)
    INT             reduce using rule 11 (declaration -> CHAR ID SEMICOLON .)
    FLOAT           reduce using rule 11 (declaration -> CHAR ID SEMICOLON .)
    CHAR            reduce using rule 11 (declaration -> CHAR ID SEMICOLON .)
    DOUBLE          reduce using rule 11 (declaration -> CHAR ID SEMICOLON .)
    VOID            reduce using rule 11 (declaration -> CHAR ID SEMICOLON .)
    $end            reduce using rule 11 (declaration -> CHAR ID SEMICOLON .)
    RBRACE          reduce using rule 11 (declaration -> CHAR ID SEMICOLON .)
    ELSE            reduce using rule 11 (declaration -> CHAR ID SEMICOLON .)


state 41

    (12) declaration -> DOUBLE ID SEMICOLON .

    ID              reduce using rule 12 (declaration -> DOUBLE ID SEMICOLON .)
    IF              reduce using rule 12 (declaration -> DOUBLE ID SEMICOLON .)
    FOR             reduce using rule 12 (declaration -> DOUBLE ID SEMICOLON .)
    LBRACE          reduce using rule 12 (declaration -> DOUBLE ID SEMICOLON .)
    INT             reduce using rule 12 (declaration -> DOUBLE ID SEMICOLON .)
    FLOAT           reduce using rule 12 (declaration -> DOUBLE ID SEMICOLON .)
    CHAR            reduce using rule 12 (declaration -> DOUBLE ID SEMICOLON .)
    DOUBLE          reduce using rule 12 (declaration -> DOUBLE ID SEMICOLON .)
    VOID            reduce using rule 12 (declaration -> DOUBLE ID SEMICOLON .)
    $end            reduce using rule 12 (declaration -> DOUBLE ID SEMICOLON .)
    RBRACE          reduce using rule 12 (declaration -> DOUBLE ID SEMICOLON .)
    ELSE            reduce using rule 12 (declaration -> DOUBLE ID SEMICOLON .)


state 42

    (13) declaration -> VOID ID SEMICOLON .

    ID              reduce using rule 13 (declaration -> VOID ID SEMICOLON .)
    IF              reduce using rule 13 (declaration -> VOID ID SEMICOLON .)
    FOR             reduce using rule 13 (declaration -> VOID ID SEMICOLON .)
    LBRACE          reduce using rule 13 (declaration -> VOID ID SEMICOLON .)
    INT             reduce using rule 13 (declaration -> VOID ID SEMICOLON .)
    FLOAT           reduce using rule 13 (declaration -> VOID ID SEMICOLON .)
    CHAR            reduce using rule 13 (declaration -> VOID ID SEMICOLON .)
    DOUBLE          reduce using rule 13 (declaration -> VOID ID SEMICOLON .)
    VOID            reduce using rule 13 (declaration -> VOID ID SEMICOLON .)
    $end            reduce using rule 13 (declaration -> VOID ID SEMICOLON .)
    RBRACE          reduce using rule 13 (declaration -> VOID ID SEMICOLON .)
    ELSE            reduce using rule 13 (declaration -> VOID ID SEMICOLON .)


state 43

    (14) assignment -> ID ASSIGN expression SEMICOLON .

    ID              reduce using rule 14 (assignment -> ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 14 (assignment -> ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 14 (assignment -> ID ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 14 (assignment -> ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 14 (assignment -> ID ASSIGN expression SEMICOLON .)
    FLOAT           reduce using rule 14 (assignment -> ID ASSIGN expression SEMICOLON .)
    CHAR            reduce using rule 14 (assignment -> ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 14 (assignment -> ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 14 (assignment -> ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 14 (assignment -> ID ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 14 (assignment -> ID ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 14 (assignment -> ID ASSIGN expression SEMICOLON .)
    CONSTANT        reduce using rule 14 (assignment -> ID ASSIGN expression SEMICOLON .)
    FLOAT_CONSTANT  reduce using rule 14 (assignment -> ID ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 14 (assignment -> ID ASSIGN expression SEMICOLON .)
    ELSE            reduce using rule 14 (assignment -> ID ASSIGN expression SEMICOLON .)


state 44

    (20) expression -> expression PLUS . expression
    (20) expression -> . expression PLUS expression
    (21) expression -> . expression MINUS expression
    (22) expression -> . expression TIMES expression
    (23) expression -> . expression DIVIDE expression
    (24) expression -> . expression MODULO expression
    (25) expression -> . MINUS expression
    (26) expression -> . ID
    (27) expression -> . CONSTANT
    (28) expression -> . FLOAT_CONSTANT
    (29) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 30
    ID              shift and go to state 28
    CONSTANT        shift and go to state 31
    FLOAT_CONSTANT  shift and go to state 32
    LPAREN          shift and go to state 33

    expression                     shift and go to state 59

state 45

    (21) expression -> expression MINUS . expression
    (20) expression -> . expression PLUS expression
    (21) expression -> . expression MINUS expression
    (22) expression -> . expression TIMES expression
    (23) expression -> . expression DIVIDE expression
    (24) expression -> . expression MODULO expression
    (25) expression -> . MINUS expression
    (26) expression -> . ID
    (27) expression -> . CONSTANT
    (28) expression -> . FLOAT_CONSTANT
    (29) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 30
    ID              shift and go to state 28
    CONSTANT        shift and go to state 31
    FLOAT_CONSTANT  shift and go to state 32
    LPAREN          shift and go to state 33

    expression                     shift and go to state 60

state 46

    (22) expression -> expression TIMES . expression
    (20) expression -> . expression PLUS expression
    (21) expression -> . expression MINUS expression
    (22) expression -> . expression TIMES expression
    (23) expression -> . expression DIVIDE expression
    (24) expression -> . expression MODULO expression
    (25) expression -> . MINUS expression
    (26) expression -> . ID
    (27) expression -> . CONSTANT
    (28) expression -> . FLOAT_CONSTANT
    (29) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 30
    ID              shift and go to state 28
    CONSTANT        shift and go to state 31
    FLOAT_CONSTANT  shift and go to state 32
    LPAREN          shift and go to state 33

    expression                     shift and go to state 61

state 47

    (23) expression -> expression DIVIDE . expression
    (20) expression -> . expression PLUS expression
    (21) expression -> . expression MINUS expression
    (22) expression -> . expression TIMES expression
    (23) expression -> . expression DIVIDE expression
    (24) expression -> . expression MODULO expression
    (25) expression -> . MINUS expression
    (26) expression -> . ID
    (27) expression -> . CONSTANT
    (28) expression -> . FLOAT_CONSTANT
    (29) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 30
    ID              shift and go to state 28
    CONSTANT        shift and go to state 31
    FLOAT_CONSTANT  shift and go to state 32
    LPAREN          shift and go to state 33

    expression                     shift and go to state 62

state 48

    (24) expression -> expression MODULO . expression
    (20) expression -> . expression PLUS expression
    (21) expression -> . expression MINUS expression
    (22) expression -> . expression TIMES expression
    (23) expression -> . expression DIVIDE expression
    (24) expression -> . expression MODULO expression
    (25) expression -> . MINUS expression
    (26) expression -> . ID
    (27) expression -> . CONSTANT
    (28) expression -> . FLOAT_CONSTANT
    (29) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 30
    ID              shift and go to state 28
    CONSTANT        shift and go to state 31
    FLOAT_CONSTANT  shift and go to state 32
    LPAREN          shift and go to state 33

    expression                     shift and go to state 63

state 49

    (25) expression -> MINUS expression .
    (20) expression -> expression . PLUS expression
    (21) expression -> expression . MINUS expression
    (22) expression -> expression . TIMES expression
    (23) expression -> expression . DIVIDE expression
    (24) expression -> expression . MODULO expression

    SEMICOLON       reduce using rule 25 (expression -> MINUS expression .)
    PLUS            reduce using rule 25 (expression -> MINUS expression .)
    MINUS           reduce using rule 25 (expression -> MINUS expression .)
    TIMES           reduce using rule 25 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 25 (expression -> MINUS expression .)
    MODULO          reduce using rule 25 (expression -> MINUS expression .)
    LT              reduce using rule 25 (expression -> MINUS expression .)
    LE              reduce using rule 25 (expression -> MINUS expression .)
    GT              reduce using rule 25 (expression -> MINUS expression .)
    GE              reduce using rule 25 (expression -> MINUS expression .)
    EQ              reduce using rule 25 (expression -> MINUS expression .)
    NE              reduce using rule 25 (expression -> MINUS expression .)
    RPAREN          reduce using rule 25 (expression -> MINUS expression .)

  ! PLUS            [ shift and go to state 44 ]
  ! MINUS           [ shift and go to state 45 ]
  ! TIMES           [ shift and go to state 46 ]
  ! DIVIDE          [ shift and go to state 47 ]
  ! MODULO          [ shift and go to state 48 ]


state 50

    (29) expression -> LPAREN expression . RPAREN
    (20) expression -> expression . PLUS expression
    (21) expression -> expression . MINUS expression
    (22) expression -> expression . TIMES expression
    (23) expression -> expression . DIVIDE expression
    (24) expression -> expression . MODULO expression

    RPAREN          shift and go to state 64
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULO          shift and go to state 48


state 51

    (15) if_statement -> IF LPAREN condition RPAREN . statement
    (16) if_statement -> IF LPAREN condition RPAREN . statement ELSE statement
    (4) statement -> . assignment
    (5) statement -> . if_statement
    (6) statement -> . for_statement
    (7) statement -> . block
    (8) statement -> . declaration
    (14) assignment -> . ID ASSIGN expression SEMICOLON
    (15) if_statement -> . IF LPAREN condition RPAREN statement
    (16) if_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (17) for_statement -> . FOR LPAREN assignment condition SEMICOLON for_increment RPAREN statement
    (19) block -> . LBRACE statement_list RBRACE
    (9) declaration -> . INT ID SEMICOLON
    (10) declaration -> . FLOAT ID SEMICOLON
    (11) declaration -> . CHAR ID SEMICOLON
    (12) declaration -> . DOUBLE ID SEMICOLON
    (13) declaration -> . VOID ID SEMICOLON

    ID              shift and go to state 9
    IF              shift and go to state 10
    FOR             shift and go to state 11
    LBRACE          shift and go to state 12
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 15
    DOUBLE          shift and go to state 16
    VOID            shift and go to state 17

    statement                      shift and go to state 65
    assignment                     shift and go to state 4
    if_statement                   shift and go to state 5
    for_statement                  shift and go to state 6
    block                          shift and go to state 7
    declaration                    shift and go to state 8

state 52

    (30) condition -> expression LT . expression
    (20) expression -> . expression PLUS expression
    (21) expression -> . expression MINUS expression
    (22) expression -> . expression TIMES expression
    (23) expression -> . expression DIVIDE expression
    (24) expression -> . expression MODULO expression
    (25) expression -> . MINUS expression
    (26) expression -> . ID
    (27) expression -> . CONSTANT
    (28) expression -> . FLOAT_CONSTANT
    (29) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 30
    ID              shift and go to state 28
    CONSTANT        shift and go to state 31
    FLOAT_CONSTANT  shift and go to state 32
    LPAREN          shift and go to state 33

    expression                     shift and go to state 66

state 53

    (31) condition -> expression LE . expression
    (20) expression -> . expression PLUS expression
    (21) expression -> . expression MINUS expression
    (22) expression -> . expression TIMES expression
    (23) expression -> . expression DIVIDE expression
    (24) expression -> . expression MODULO expression
    (25) expression -> . MINUS expression
    (26) expression -> . ID
    (27) expression -> . CONSTANT
    (28) expression -> . FLOAT_CONSTANT
    (29) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 30
    ID              shift and go to state 28
    CONSTANT        shift and go to state 31
    FLOAT_CONSTANT  shift and go to state 32
    LPAREN          shift and go to state 33

    expression                     shift and go to state 67

state 54

    (32) condition -> expression GT . expression
    (20) expression -> . expression PLUS expression
    (21) expression -> . expression MINUS expression
    (22) expression -> . expression TIMES expression
    (23) expression -> . expression DIVIDE expression
    (24) expression -> . expression MODULO expression
    (25) expression -> . MINUS expression
    (26) expression -> . ID
    (27) expression -> . CONSTANT
    (28) expression -> . FLOAT_CONSTANT
    (29) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 30
    ID              shift and go to state 28
    CONSTANT        shift and go to state 31
    FLOAT_CONSTANT  shift and go to state 32
    LPAREN          shift and go to state 33

    expression                     shift and go to state 68

state 55

    (33) condition -> expression GE . expression
    (20) expression -> . expression PLUS expression
    (21) expression -> . expression MINUS expression
    (22) expression -> . expression TIMES expression
    (23) expression -> . expression DIVIDE expression
    (24) expression -> . expression MODULO expression
    (25) expression -> . MINUS expression
    (26) expression -> . ID
    (27) expression -> . CONSTANT
    (28) expression -> . FLOAT_CONSTANT
    (29) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 30
    ID              shift and go to state 28
    CONSTANT        shift and go to state 31
    FLOAT_CONSTANT  shift and go to state 32
    LPAREN          shift and go to state 33

    expression                     shift and go to state 69

state 56

    (34) condition -> expression EQ . expression
    (20) expression -> . expression PLUS expression
    (21) expression -> . expression MINUS expression
    (22) expression -> . expression TIMES expression
    (23) expression -> . expression DIVIDE expression
    (24) expression -> . expression MODULO expression
    (25) expression -> . MINUS expression
    (26) expression -> . ID
    (27) expression -> . CONSTANT
    (28) expression -> . FLOAT_CONSTANT
    (29) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 30
    ID              shift and go to state 28
    CONSTANT        shift and go to state 31
    FLOAT_CONSTANT  shift and go to state 32
    LPAREN          shift and go to state 33

    expression                     shift and go to state 70

state 57

    (35) condition -> expression NE . expression
    (20) expression -> . expression PLUS expression
    (21) expression -> . expression MINUS expression
    (22) expression -> . expression TIMES expression
    (23) expression -> . expression DIVIDE expression
    (24) expression -> . expression MODULO expression
    (25) expression -> . MINUS expression
    (26) expression -> . ID
    (27) expression -> . CONSTANT
    (28) expression -> . FLOAT_CONSTANT
    (29) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 30
    ID              shift and go to state 28
    CONSTANT        shift and go to state 31
    FLOAT_CONSTANT  shift and go to state 32
    LPAREN          shift and go to state 33

    expression                     shift and go to state 71

state 58

    (17) for_statement -> FOR LPAREN assignment condition . SEMICOLON for_increment RPAREN statement

    SEMICOLON       shift and go to state 72


state 59

    (20) expression -> expression PLUS expression .
    (20) expression -> expression . PLUS expression
    (21) expression -> expression . MINUS expression
    (22) expression -> expression . TIMES expression
    (23) expression -> expression . DIVIDE expression
    (24) expression -> expression . MODULO expression

    SEMICOLON       reduce using rule 20 (expression -> expression PLUS expression .)
    PLUS            reduce using rule 20 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 20 (expression -> expression PLUS expression .)
    LT              reduce using rule 20 (expression -> expression PLUS expression .)
    LE              reduce using rule 20 (expression -> expression PLUS expression .)
    GT              reduce using rule 20 (expression -> expression PLUS expression .)
    GE              reduce using rule 20 (expression -> expression PLUS expression .)
    EQ              reduce using rule 20 (expression -> expression PLUS expression .)
    NE              reduce using rule 20 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 20 (expression -> expression PLUS expression .)
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULO          shift and go to state 48

  ! TIMES           [ reduce using rule 20 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 20 (expression -> expression PLUS expression .) ]
  ! MODULO          [ reduce using rule 20 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 44 ]
  ! MINUS           [ shift and go to state 45 ]


state 60

    (21) expression -> expression MINUS expression .
    (20) expression -> expression . PLUS expression
    (21) expression -> expression . MINUS expression
    (22) expression -> expression . TIMES expression
    (23) expression -> expression . DIVIDE expression
    (24) expression -> expression . MODULO expression

    SEMICOLON       reduce using rule 21 (expression -> expression MINUS expression .)
    PLUS            reduce using rule 21 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 21 (expression -> expression MINUS expression .)
    LT              reduce using rule 21 (expression -> expression MINUS expression .)
    LE              reduce using rule 21 (expression -> expression MINUS expression .)
    GT              reduce using rule 21 (expression -> expression MINUS expression .)
    GE              reduce using rule 21 (expression -> expression MINUS expression .)
    EQ              reduce using rule 21 (expression -> expression MINUS expression .)
    NE              reduce using rule 21 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 21 (expression -> expression MINUS expression .)
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULO          shift and go to state 48

  ! TIMES           [ reduce using rule 21 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 21 (expression -> expression MINUS expression .) ]
  ! MODULO          [ reduce using rule 21 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 44 ]
  ! MINUS           [ shift and go to state 45 ]


state 61

    (22) expression -> expression TIMES expression .
    (20) expression -> expression . PLUS expression
    (21) expression -> expression . MINUS expression
    (22) expression -> expression . TIMES expression
    (23) expression -> expression . DIVIDE expression
    (24) expression -> expression . MODULO expression

    SEMICOLON       reduce using rule 22 (expression -> expression TIMES expression .)
    PLUS            reduce using rule 22 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 22 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 22 (expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 22 (expression -> expression TIMES expression .)
    MODULO          reduce using rule 22 (expression -> expression TIMES expression .)
    LT              reduce using rule 22 (expression -> expression TIMES expression .)
    LE              reduce using rule 22 (expression -> expression TIMES expression .)
    GT              reduce using rule 22 (expression -> expression TIMES expression .)
    GE              reduce using rule 22 (expression -> expression TIMES expression .)
    EQ              reduce using rule 22 (expression -> expression TIMES expression .)
    NE              reduce using rule 22 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 22 (expression -> expression TIMES expression .)

  ! PLUS            [ shift and go to state 44 ]
  ! MINUS           [ shift and go to state 45 ]
  ! TIMES           [ shift and go to state 46 ]
  ! DIVIDE          [ shift and go to state 47 ]
  ! MODULO          [ shift and go to state 48 ]


state 62

    (23) expression -> expression DIVIDE expression .
    (20) expression -> expression . PLUS expression
    (21) expression -> expression . MINUS expression
    (22) expression -> expression . TIMES expression
    (23) expression -> expression . DIVIDE expression
    (24) expression -> expression . MODULO expression

    SEMICOLON       reduce using rule 23 (expression -> expression DIVIDE expression .)
    PLUS            reduce using rule 23 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 23 (expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 23 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 23 (expression -> expression DIVIDE expression .)
    MODULO          reduce using rule 23 (expression -> expression DIVIDE expression .)
    LT              reduce using rule 23 (expression -> expression DIVIDE expression .)
    LE              reduce using rule 23 (expression -> expression DIVIDE expression .)
    GT              reduce using rule 23 (expression -> expression DIVIDE expression .)
    GE              reduce using rule 23 (expression -> expression DIVIDE expression .)
    EQ              reduce using rule 23 (expression -> expression DIVIDE expression .)
    NE              reduce using rule 23 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 23 (expression -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 44 ]
  ! MINUS           [ shift and go to state 45 ]
  ! TIMES           [ shift and go to state 46 ]
  ! DIVIDE          [ shift and go to state 47 ]
  ! MODULO          [ shift and go to state 48 ]


state 63

    (24) expression -> expression MODULO expression .
    (20) expression -> expression . PLUS expression
    (21) expression -> expression . MINUS expression
    (22) expression -> expression . TIMES expression
    (23) expression -> expression . DIVIDE expression
    (24) expression -> expression . MODULO expression

    SEMICOLON       reduce using rule 24 (expression -> expression MODULO expression .)
    PLUS            reduce using rule 24 (expression -> expression MODULO expression .)
    MINUS           reduce using rule 24 (expression -> expression MODULO expression .)
    TIMES           reduce using rule 24 (expression -> expression MODULO expression .)
    DIVIDE          reduce using rule 24 (expression -> expression MODULO expression .)
    MODULO          reduce using rule 24 (expression -> expression MODULO expression .)
    LT              reduce using rule 24 (expression -> expression MODULO expression .)
    LE              reduce using rule 24 (expression -> expression MODULO expression .)
    GT              reduce using rule 24 (expression -> expression MODULO expression .)
    GE              reduce using rule 24 (expression -> expression MODULO expression .)
    EQ              reduce using rule 24 (expression -> expression MODULO expression .)
    NE              reduce using rule 24 (expression -> expression MODULO expression .)
    RPAREN          reduce using rule 24 (expression -> expression MODULO expression .)

  ! PLUS            [ shift and go to state 44 ]
  ! MINUS           [ shift and go to state 45 ]
  ! TIMES           [ shift and go to state 46 ]
  ! DIVIDE          [ shift and go to state 47 ]
  ! MODULO          [ shift and go to state 48 ]


state 64

    (29) expression -> LPAREN expression RPAREN .

    SEMICOLON       reduce using rule 29 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 29 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 29 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 29 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 29 (expression -> LPAREN expression RPAREN .)
    MODULO          reduce using rule 29 (expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 29 (expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 29 (expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 29 (expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 29 (expression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 29 (expression -> LPAREN expression RPAREN .)
    NE              reduce using rule 29 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 29 (expression -> LPAREN expression RPAREN .)


state 65

    (15) if_statement -> IF LPAREN condition RPAREN statement .
    (16) if_statement -> IF LPAREN condition RPAREN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    ID              reduce using rule 15 (if_statement -> IF LPAREN condition RPAREN statement .)
    IF              reduce using rule 15 (if_statement -> IF LPAREN condition RPAREN statement .)
    FOR             reduce using rule 15 (if_statement -> IF LPAREN condition RPAREN statement .)
    LBRACE          reduce using rule 15 (if_statement -> IF LPAREN condition RPAREN statement .)
    INT             reduce using rule 15 (if_statement -> IF LPAREN condition RPAREN statement .)
    FLOAT           reduce using rule 15 (if_statement -> IF LPAREN condition RPAREN statement .)
    CHAR            reduce using rule 15 (if_statement -> IF LPAREN condition RPAREN statement .)
    DOUBLE          reduce using rule 15 (if_statement -> IF LPAREN condition RPAREN statement .)
    VOID            reduce using rule 15 (if_statement -> IF LPAREN condition RPAREN statement .)
    $end            reduce using rule 15 (if_statement -> IF LPAREN condition RPAREN statement .)
    RBRACE          reduce using rule 15 (if_statement -> IF LPAREN condition RPAREN statement .)
    ELSE            shift and go to state 73

  ! ELSE            [ reduce using rule 15 (if_statement -> IF LPAREN condition RPAREN statement .) ]


state 66

    (30) condition -> expression LT expression .
    (20) expression -> expression . PLUS expression
    (21) expression -> expression . MINUS expression
    (22) expression -> expression . TIMES expression
    (23) expression -> expression . DIVIDE expression
    (24) expression -> expression . MODULO expression

    RPAREN          reduce using rule 30 (condition -> expression LT expression .)
    SEMICOLON       reduce using rule 30 (condition -> expression LT expression .)
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULO          shift and go to state 48


state 67

    (31) condition -> expression LE expression .
    (20) expression -> expression . PLUS expression
    (21) expression -> expression . MINUS expression
    (22) expression -> expression . TIMES expression
    (23) expression -> expression . DIVIDE expression
    (24) expression -> expression . MODULO expression

    RPAREN          reduce using rule 31 (condition -> expression LE expression .)
    SEMICOLON       reduce using rule 31 (condition -> expression LE expression .)
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULO          shift and go to state 48


state 68

    (32) condition -> expression GT expression .
    (20) expression -> expression . PLUS expression
    (21) expression -> expression . MINUS expression
    (22) expression -> expression . TIMES expression
    (23) expression -> expression . DIVIDE expression
    (24) expression -> expression . MODULO expression

    RPAREN          reduce using rule 32 (condition -> expression GT expression .)
    SEMICOLON       reduce using rule 32 (condition -> expression GT expression .)
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULO          shift and go to state 48


state 69

    (33) condition -> expression GE expression .
    (20) expression -> expression . PLUS expression
    (21) expression -> expression . MINUS expression
    (22) expression -> expression . TIMES expression
    (23) expression -> expression . DIVIDE expression
    (24) expression -> expression . MODULO expression

    RPAREN          reduce using rule 33 (condition -> expression GE expression .)
    SEMICOLON       reduce using rule 33 (condition -> expression GE expression .)
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULO          shift and go to state 48


state 70

    (34) condition -> expression EQ expression .
    (20) expression -> expression . PLUS expression
    (21) expression -> expression . MINUS expression
    (22) expression -> expression . TIMES expression
    (23) expression -> expression . DIVIDE expression
    (24) expression -> expression . MODULO expression

    RPAREN          reduce using rule 34 (condition -> expression EQ expression .)
    SEMICOLON       reduce using rule 34 (condition -> expression EQ expression .)
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULO          shift and go to state 48


state 71

    (35) condition -> expression NE expression .
    (20) expression -> expression . PLUS expression
    (21) expression -> expression . MINUS expression
    (22) expression -> expression . TIMES expression
    (23) expression -> expression . DIVIDE expression
    (24) expression -> expression . MODULO expression

    RPAREN          reduce using rule 35 (condition -> expression NE expression .)
    SEMICOLON       reduce using rule 35 (condition -> expression NE expression .)
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULO          shift and go to state 48


state 72

    (17) for_statement -> FOR LPAREN assignment condition SEMICOLON . for_increment RPAREN statement
    (18) for_increment -> . ID ASSIGN expression

    ID              shift and go to state 75

    for_increment                  shift and go to state 74

state 73

    (16) if_statement -> IF LPAREN condition RPAREN statement ELSE . statement
    (4) statement -> . assignment
    (5) statement -> . if_statement
    (6) statement -> . for_statement
    (7) statement -> . block
    (8) statement -> . declaration
    (14) assignment -> . ID ASSIGN expression SEMICOLON
    (15) if_statement -> . IF LPAREN condition RPAREN statement
    (16) if_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (17) for_statement -> . FOR LPAREN assignment condition SEMICOLON for_increment RPAREN statement
    (19) block -> . LBRACE statement_list RBRACE
    (9) declaration -> . INT ID SEMICOLON
    (10) declaration -> . FLOAT ID SEMICOLON
    (11) declaration -> . CHAR ID SEMICOLON
    (12) declaration -> . DOUBLE ID SEMICOLON
    (13) declaration -> . VOID ID SEMICOLON

    ID              shift and go to state 9
    IF              shift and go to state 10
    FOR             shift and go to state 11
    LBRACE          shift and go to state 12
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 15
    DOUBLE          shift and go to state 16
    VOID            shift and go to state 17

    statement                      shift and go to state 76
    assignment                     shift and go to state 4
    if_statement                   shift and go to state 5
    for_statement                  shift and go to state 6
    block                          shift and go to state 7
    declaration                    shift and go to state 8

state 74

    (17) for_statement -> FOR LPAREN assignment condition SEMICOLON for_increment . RPAREN statement

    RPAREN          shift and go to state 77


state 75

    (18) for_increment -> ID . ASSIGN expression

    ASSIGN          shift and go to state 78


state 76

    (16) if_statement -> IF LPAREN condition RPAREN statement ELSE statement .

    ID              reduce using rule 16 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    IF              reduce using rule 16 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    FOR             reduce using rule 16 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    LBRACE          reduce using rule 16 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    INT             reduce using rule 16 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    FLOAT           reduce using rule 16 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    CHAR            reduce using rule 16 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    DOUBLE          reduce using rule 16 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    VOID            reduce using rule 16 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    $end            reduce using rule 16 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    RBRACE          reduce using rule 16 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)
    ELSE            reduce using rule 16 (if_statement -> IF LPAREN condition RPAREN statement ELSE statement .)


state 77

    (17) for_statement -> FOR LPAREN assignment condition SEMICOLON for_increment RPAREN . statement
    (4) statement -> . assignment
    (5) statement -> . if_statement
    (6) statement -> . for_statement
    (7) statement -> . block
    (8) statement -> . declaration
    (14) assignment -> . ID ASSIGN expression SEMICOLON
    (15) if_statement -> . IF LPAREN condition RPAREN statement
    (16) if_statement -> . IF LPAREN condition RPAREN statement ELSE statement
    (17) for_statement -> . FOR LPAREN assignment condition SEMICOLON for_increment RPAREN statement
    (19) block -> . LBRACE statement_list RBRACE
    (9) declaration -> . INT ID SEMICOLON
    (10) declaration -> . FLOAT ID SEMICOLON
    (11) declaration -> . CHAR ID SEMICOLON
    (12) declaration -> . DOUBLE ID SEMICOLON
    (13) declaration -> . VOID ID SEMICOLON

    ID              shift and go to state 9
    IF              shift and go to state 10
    FOR             shift and go to state 11
    LBRACE          shift and go to state 12
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 15
    DOUBLE          shift and go to state 16
    VOID            shift and go to state 17

    assignment                     shift and go to state 4
    statement                      shift and go to state 79
    if_statement                   shift and go to state 5
    for_statement                  shift and go to state 6
    block                          shift and go to state 7
    declaration                    shift and go to state 8

state 78

    (18) for_increment -> ID ASSIGN . expression
    (20) expression -> . expression PLUS expression
    (21) expression -> . expression MINUS expression
    (22) expression -> . expression TIMES expression
    (23) expression -> . expression DIVIDE expression
    (24) expression -> . expression MODULO expression
    (25) expression -> . MINUS expression
    (26) expression -> . ID
    (27) expression -> . CONSTANT
    (28) expression -> . FLOAT_CONSTANT
    (29) expression -> . LPAREN expression RPAREN

    MINUS           shift and go to state 30
    ID              shift and go to state 28
    CONSTANT        shift and go to state 31
    FLOAT_CONSTANT  shift and go to state 32
    LPAREN          shift and go to state 33

    expression                     shift and go to state 80

state 79

    (17) for_statement -> FOR LPAREN assignment condition SEMICOLON for_increment RPAREN statement .

    ID              reduce using rule 17 (for_statement -> FOR LPAREN assignment condition SEMICOLON for_increment RPAREN statement .)
    IF              reduce using rule 17 (for_statement -> FOR LPAREN assignment condition SEMICOLON for_increment RPAREN statement .)
    FOR             reduce using rule 17 (for_statement -> FOR LPAREN assignment condition SEMICOLON for_increment RPAREN statement .)
    LBRACE          reduce using rule 17 (for_statement -> FOR LPAREN assignment condition SEMICOLON for_increment RPAREN statement .)
    INT             reduce using rule 17 (for_statement -> FOR LPAREN assignment condition SEMICOLON for_increment RPAREN statement .)
    FLOAT           reduce using rule 17 (for_statement -> FOR LPAREN assignment condition SEMICOLON for_increment RPAREN statement .)
    CHAR            reduce using rule 17 (for_statement -> FOR LPAREN assignment condition SEMICOLON for_increment RPAREN statement .)
    DOUBLE          reduce using rule 17 (for_statement -> FOR LPAREN assignment condition SEMICOLON for_increment RPAREN statement .)
    VOID            reduce using rule 17 (for_statement -> FOR LPAREN assignment condition SEMICOLON for_increment RPAREN statement .)
    $end            reduce using rule 17 (for_statement -> FOR LPAREN assignment condition SEMICOLON for_increment RPAREN statement .)
    RBRACE          reduce using rule 17 (for_statement -> FOR LPAREN assignment condition SEMICOLON for_increment RPAREN statement .)
    ELSE            reduce using rule 17 (for_statement -> FOR LPAREN assignment condition SEMICOLON for_increment RPAREN statement .)


state 80

    (18) for_increment -> ID ASSIGN expression .
    (20) expression -> expression . PLUS expression
    (21) expression -> expression . MINUS expression
    (22) expression -> expression . TIMES expression
    (23) expression -> expression . DIVIDE expression
    (24) expression -> expression . MODULO expression

    RPAREN          reduce using rule 18 (for_increment -> ID ASSIGN expression .)
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47
    MODULO          shift and go to state 48

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 65 resolved as shift
